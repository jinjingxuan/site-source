---
title: 日常-2020.3.19
date: 2020-03-19 09:52:01
categories: 日常
---

* cooike和session的区别

* html5的一些标签
* 数组和链表的对比
* 链表反转
* 给一个链表，输出链表中倒数第k个结点
* 输入两个单增的链表，合并后新链表单调不减
* 轮播图怎么实现
* 设计模式你了解哪些
* 项目中你遇到了哪些坑

<!--more-->

## 1.cooike和session的区别

Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了 。

## 2.html5的一些标签

```
<header>:定义区段或页面的页眉.(头部)
<footer>:定义区段或页面的页脚.(足部)
<section>:定义文档中的区段.
<article>:定义文章.
<aside>:定义页面内容之外的内容.
<details>:定义元素的细节.
<audio>:定义声音内容.
<video>:定义视频.
<iframe>:内联框架.
```

## 3.数组和链表的对比

数组存储方式采用线性结构，声明数组时需要声明类型，并且大小也会固定：

* 优点：

　　　　因此访问数组元素可根据数组下标随机访问，O(1).

* 缺点：

　　　　大小固定，可能会造成空间浪费，或空间不够影响程序运行；

　　　　插入和删除元素却比较麻烦，可能需要移动部分数组元素以保证数组元素的物理位置保持连续。

链表采用链式存储结构，在声明时只需声明结构类型，：

* 优点：

　　　　链表大小在实际使用中可以动态增大和减小；

　　　　插入和删除操作就很方便，只需修改该元素节点邻接元素即可O(1).

* 缺点：

　　　　访问元素比较费时，需要逐个节点进行查看或能找到目标元素。

## 4.链表反转

```js
function Reverse(p){
    var pre=null
    var next=null
    while(p!=null){
        next=p.next
        p.next=pre //反转指针
        pre=p      
        p=next
    }
}
```

## 5.给一个链表，输出链表中倒数第k个结点

```js
let arr = []
while(head){
    arr.unshift(head)
    head=head.next
}
return arr[k-1]
```

## 6.输入两个单增的链表，合并后新链表单调不减

```js
function merge(pHead1,pHead2){
    if(pHead1==null) return pHead2
    else if(pHead2==null) return pHead1
    let result =[]
    if(pHead1.val<pHead2.val){
        result = pHead1
        result.next = merge(pHead1.next,pHead2)
    }else{
        result = pHead2
        result.next = merge(pHead1,pHead2.next)
    }
    return result
}
```

## 7. 怎么实现轮播图

```js
            // 若果有在等待的定时器，则清掉
            if (timer) {
                clearInterval(timer);
                timer = null;
            }
            //自动切换
            timer = setInterval(autoPlay, 4000);

            //定义自动播放函数
            function autoPlay() {
                index++;
                if (list.length <=index) {
                    index = 0;
                }

                changeImg(index);
                // alert("我正在autoplay");
            }

            // 定义图片切换函数（根据当前的index值也就是curindex）
            function changeImg(curIndex) {
                for (var j = 0; j < list.length; j++) {
                    list[j].className = "";
                }
                // 改变当前显示索引
                list[curIndex].className = "on";
                pic.style.marginLeft = -1920 * curIndex + "px";
                index = curIndex;
            }

            // 鼠标划过整个容器时停止自动播放
            wrap.onmouseover = function(curIndex) {
                clearInterval(timer);
                //点击右按钮
            }

            // 鼠标离开整个容器时继续播放至下一张
            wrap.onmouseout = function() {
                timer = setInterval(autoPlay, 4000);
                // alert("鼠标移走了");
            }

            // 遍历所有数字导航实现划过切换至对应的图片
            for (var i = 0; i < list.length; i++) {
                list[i].id = i;
                list[i].onmouseover = function() {
                    clearInterval(timer);
                    changeImg(this.id);
                }
            }
```

## 8. 设计模式

* 单例模式（Singleton）：又称为单体模式，是只允许实例化一次的对象类。有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性与方法。 
* 简单工厂模式：又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。 
* 工厂方法模式（Factory Method）：通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。 
* 抽象工厂模式：通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例。 
* 建造者模式（Builder：将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。 

## 9. 项目中遇到过那些坑

* for循环给li设置点击事件，闭包，let