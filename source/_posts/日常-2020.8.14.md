---
title: 日常-8.14
date: 2020-08-14 10:27:54
categories: 日常
---

* Maximum call stack size exceeded
* 拼接参数
* 一个示例
* css缓存问题
* for..of遍历对象，可迭代
* for...in的坑
* 指数运算符 2**10

<!--more-->

## Maximum call stack size exceeded

一般这种错误是指超出最大调用堆栈大小，出现场景：递归调用

```js
            Object.defineProperty(obj,key,{
                get: function(){
                    console.log(`get key = ${obj[key]}`)
                }
            })

// 在执行obj.key时会出现该错误
```

## 拼接参数

* 如何保证有这个参数时拼接，没有的时候不拼接呢

```js
	let options = {
        'name': this.name,
        'age': this.age,
        'sex': this.sex
      }
      let paramsurl = ''
      for(const key in options) {
        const value = options[key]
        value &&
          (paramsurl += paramsurl ? `&${key}=${value}` : `${key}=${value}`)
      }
```

## 一个示例

```js
const obj = {
    max(a,b) {
        return Math.max(a,b)
    }
}
// 优化为
const obj = {
    max: Math.max
}
```

## css缓存问题

修改css文件进行发布时，文件名如果不变，浏览器可能直接去取缓存，为了解决这个问题，在文件名后面加hash随机值。

```js
// 在webpack.prod.conf.js中的配置
new ExtractTextPlugin({ 
      filename: utils.assetsPath('css/[name].[chunkhash:8].css'), //css/[name].[contenthash].css
	  // ...
})
```

## for..of遍历对象，可迭代接口

当我们用for...of遍历对象时

```js
const obj = { foo: 123, bar: 456 }

for(const item of obj) {
    console.log(item)
}
// 报错 obj is not iterable
```

Array,Set,Map都有Iterator属性，所以可以用for...of遍历

```js
const arr = [1, 2, 3]
arr[Symbol.iterator]()

// Array Iterator {} 其中还有next方法

const iterator = arr[Symbol.iterator]()
iterator.next() // {value: 1, done: false}
iterator.next() // {value: 2, done: false}
iterator.next() // {value: 3, done: false}
iterator.next() // {value: undefined, done: true}
```

for..of其实就是去调用iterator接口

```js
// 迭代器模式

// 场景：协同开发一个任务清单

// a的代码
const todos = {
    life: ['吃饭', '睡觉', '打豆豆'],
    learn: ['语文', '数学', '外语'],
    work: ['喝茶']
}

// b的代码,需要知道对象结构
for (const item of todos.life) {
    console.log(item)
}
for (const item of todos.learn) {
    console.log(item)
}
for (const item of todos.work) {
    console.log(item)
}

// 这时如果我在a代码的todos对象中加一个接口
each: function (callback) {
    const all = [].concat(this.life, this.learn, this.work)
    for(const item of all) {
        callback(item)
    }
}

// b中就可以这样调用
todo.each(item => console.log(item))
```

迭代器实现：对外提供统一遍历接口

```js
const todos = {
    life: ['吃饭', '睡觉', '打豆豆'],
    learn: ['语文', '数学', '外语'],
    work: ['喝茶'],
    
    [Symbol.iterator]: function () {
        const all = [...this.life, ...this.learn, ...this.work]
        let index = 0
        return {
            next: function () {
                return {
                    value: all[index]
                    done: index++ >= all.length
                }
            }
        }
    }
}

for(const item of todos) {
    console.log(item)
}
```

生成器实现迭代器

```js
const todos = {
    life: ['吃饭', '睡觉', '打豆豆'],
    learn: ['语文', '数学', '外语'],
    work: ['喝茶'],
    
    [Symbol.iterator]: function * () {
        const all = [...this.life, ...this.learn, ...this.work]
        for(const item of all) {
            yield item
        }
    }
}

for(const item of todos) {
    console.log(item)
}
```

## for...in的坑

```js
arr = [1,2,3,4]
for(let i in arr){
    console.log(i + 1)
}
// 输出
// 01
// 11
// 21
// 31
```

