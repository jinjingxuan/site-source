---
title: 面试题（四）
date: 2018-03-09 09:52:01
categories: 面试
---

* 深拷贝与浅拷贝
* 什么是BFC，BFC的布局规则是什么，如何创建BFC
* 隐藏页面中某个元素的方法
* 说一下你对JS执行上下文和作用域链的理解
* 防抖函数，节流函数的作用与实现
* 什么是闭包，闭包的作用是什么
* 实现一个flattenDeep函数，把嵌套的数组扁平化
* 关于reduce函数
* 数组去重的方法
* filter 和 map 处理数据

##  深拷贝与浅拷贝

#### 场景

```js
var a = [1,2,3];
var b = a;
b.push(4); // b中添加了一个4
alert(a); // a变成了[1,2,3,4] 

var obj = {a:10};
var obj2 = obj;
obj2.a = 20; // obj2.a改变了，
alert(obj.a); // 20，obj的a跟着改变 
```

深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。

#### 深拷贝

> 深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。

#### 浅拷贝

> 浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。

```js
 //Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象
let obj = {
    name:'a',
    hobbies:{
        like:'coding',
        hate:'reading'
    }
}     
let obj2 = Object.assign({},obj)
let obj3 = JSON.parse(JSON.stringify(obj))
obj.hobbies.like = 'reading'
obj.name='b'
console.log(obj)
console.log(obj2) //name:a,like:reading,说明没有实现深拷贝

//JSON.parse(JSON.stringify(obj))我们一般用来深拷贝，其过程说白了 就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象
console.log(obj3) //实现了深拷贝，但是存在问题
```

> JSON.parse(JSON.stringify(obj)) 的问题：
>
> 1. 对象的属性值是函数时，无法拷贝。
> 2. 原型链上的属性无法拷贝
> 3. 不能正确的处理 Date 类型的数据
> 4. 不能处理 RegExp
> 5. 会忽略 symbol
> 6. 会忽略 undefined

## 什么是BFC，BFC的布局规则是什么，如何创建BFC

* [盒子模型](https://www.jinjingxuan.com/2020/11/26/%E6%95%B4%E7%90%86-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/)

## 隐藏页面中某个元素的方法

隐藏类型：

* 完全隐藏：元素从渲染树中消失，不占据空间
* 视觉上隐藏：屏幕中不可见，占据空间
* 语义上隐藏：读屏软件不可读，但正常占据空间

完全隐藏：

```js
1. display: none;
2. <div hidden></div>  hidden属性
```

视觉上隐藏：

```js
1.利用poisition和盒模型将元素移出可视区范围
position:absolute;
left:-9999px;

2.利用transform
（1）缩放：transform: scale(0);
（2）移动：transform：translateX(-9999px)
 (3) 旋转：transform: rotateY(90deg);
 
3.透明度
opacity: 0;

4.visibility: hidden;

5.层级覆盖， z-index 属性
z-index: -999;

6.clip-path 裁剪
clip-path: polygon(00,00,00,00);
```

语义上隐藏

```js
<div aria-hidden="true">
</div>
```

##  说一下你对JS执行上下文栈和作用域链的理解

js执行上下文

> 执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。
>
> 执行上下文类型分为：
> 1.全局执行上下文
> 2.函数执行上下文

作用域

> 作用域:控制着变量与函数的可见性和生命周期。
>
> 作用域有两种工作模型：词法作用域和动态作用域，JS采用的是词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。
>
> 分为：
> 1.全局作用域
> 2.局部作用域
>
> 局部作用域又分为：
> 1.函数作用域
> 2.块级作用域

js执行上下文栈

```js
首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。

当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。

function fun3(){
    console.log('fun3')
}
function fun2(){
    fun3()
}
function fun1(){
    fun2()
}
fun1()
入栈：全局，f1,f2,f3
出栈：f3,f2,f1
```

作用域链

```js
作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。 

var a=10;
function fn1(){
    var b=20;
    console.log(fn2)
    function fn2(){
        a=20
    }
    return fn2
}
fn1()()

fn2中没有a,向上寻找，fn1中也没有，向上找，在全局作用域中找到了
```

## 防抖函数，节流函数的作用与实现

* [手写代码整理](https://www.jinjingxuan.com/2020/03/20/%E6%95%B4%E7%90%86-%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/)

## 什么是闭包，闭包的作用是什么

闭包是指有权访问另一个函数作用域中的变量的函数 

```js
//创建一个闭包
function foo(){
    var a=2;
    return function fn(){
        console.log(a)
    }
}
let func = foo()
func()//输出2
```

闭包的作用：

（1）访问另一个函数作用域中的变量

（2）私有化变量

```js
function privateVariable() {
    var value;
    this.setValue = function(value) {
        value= value;
    };
    this.getValue = function() {
        return value;
    };
}
var x = new privateVariable();
x.setValue("abcd");
console.log(x.value); //undefined
console.log(x.getValue ()); //abcd
```

 （3）模拟块级作用域

```js
for(var i=0;i<10;i++){
    (function(i){
        console.log(i)
    })(i)
}
```

## 实现一个flattenDeep函数，把嵌套的数组扁平化

`flattenDeep([1, [2, [3, [4]], 5]]); //[1, 2, 3, 4, 5]`

（1）ES6的flat方法

```js
//flat 方法，用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数组没有影响。
//flat 默认只会 “拉平” 一层，如果想要 “拉平” 多层的嵌套数组，需要给 flat 传递一个整数，表示想要拉平的层数。

function flattenDeep(arr,deepLength){
    return arr.flat(deepLength)
}

//当传递的整数大于数组嵌套的层数时，会将数组拉平为一维数组
function flattenDeep(arr){
    return arr.flat(1000)
}
```

（2）利用reduce和concat

```js
function flattenDeep(arr){
    return arr.reduce((acc,val)=>Array.isArray(val)?acc.concat(flattenDeep(val)):
                     acc.concat(val),[])
}
```

（3）利用栈

```js
function flattenDeep(input){
    const stack = [...input];
    const res = [];
    while(stack.length){
        //从stack中取值
        const next = stack.pop()
        if(Array.isArray(next)){//如果取出的是数组，继续放到栈里
            stack.push(...next);
        }else{
            res.push(next)//如果不是数组了，直接放到结果
        }
    }
    return res.reverse();
}
```

## 关于reduce函数

> reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。对空数组是不会执行回调函数的。 

```js
//数组求和
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const sum = arr.reduce(function (prev, current) {
    return prev+current
}, 0)
console.log(sum) //55

//合并二维数组
var twoArr = [['mu','zi'],['dig','big'],['lucky','jiji']];
var oneArr = twoArr.reduce(function(total,currentValue){
  // console.log(total)
  return total.concat(currentValue);
})
console.log(oneArr);//["mu", "zi", "dig", "big", "lucky", "jiji"]
```

## 数组去重

（1）reduce + includes

```js
let arr = [1, 2, 2, 4, null, null].reduce((prev, current) => {
    return prev.includes(current) ? prev : prev.concat(current);
}, []);
```

（2）利用ES6的Set数据结构

> `set` 类似于数组，且成员值不重复都是唯一的，`set`本身是一个构造函数。 

```js
let arr = [1,2,2,3]
[...new Set(arr)]  //[1,2,3]
```

（3）for循环+splice

```js
for(var i=0;i<arr.length;i++){
    for(var j=i+1;j<arr.length;j++){
        if(arr[i]==arr[j]){
            arr.splice(j,1)
            j--
        }
    }
}
```

（4）利用indexOf

```js
var array = [];
for (var i = 0; i < arr.length; i++) {
    if (array .indexOf(arr[i]) === -1) {
            array .push(arr[i])
     }
}
```

（5）利用sort

```js
arr = arr.sort()
var array = []
for(var i=0;i<arr.length;i++){
    if(arr[i]!==arr[i-1]){
        array.push(arr[i])
    }
}
```

（6）利用includes

```js
var array = []
for(var i=0;i<arr.length;i++){
    if(!array.includes(arr[i])){
        array.push(arr[i])
    }
}
```

## filter 和 map 处理数据

比如现在接口返回如下格式的数据：

```json
[
    {
        agent: {
            avatar: "https://"
            cityId: 1
            imCount: 1
            likeCount: 0
            liveness: 110
            replyRate: "0"
            role: 1   
        }
        category: 4
        categoryDetail: "其他"
        createTime: "10:01"
    }, 
    {
        agent: {
            avatar: "https://"
            cityId: 1
            imCount: 1
            likeCount: 0
            liveness: 110
            replyRate: "0"
            role: 1   
        }
        category: 4
        categoryDetail: "其他"
        createTime: "10:01"
    },
    // 一共10条
]
```

>  要求：拿到有 agent 数据的对象，并且将 agent 中的数据和对象中原本的数据抽出来需要的部分组成一个 item，并且自定义名称，加到原有数组中

```js
let data = res.data.list.filter(item => {
    return item.agent // 过滤有 agent 的
})
let list = data.map(item => { 
    return {
        avatar: item.agent.avatar,
        role: item.agent.role,
        createTime: item.createTime
    }
})
this.dynamicList.push(...list) // 加入到原来的数组中
```

