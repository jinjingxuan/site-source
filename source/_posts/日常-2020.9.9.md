---
title: 日常-9.9
date: 2020-09-09 10:27:54
categories: 日常
---

*  filter 过滤  / map 处理接口数据
*  margin 写3个值
*  vscode 折叠展开代码
*  如何快速的删除 node_modules
*  $nextTick
*  关于图片处理
*  iterm2

<!--more-->

## 如何使用 filter 和 map 处理接口数据

比如现在接口返回如下格式的数据：

```json
[
 	{
        agent: {
            avatar: "https://"
            cityId: 1
            imCount: 1
            likeCount: 0
            liveness: 110
            replyRate: "0"
            role: 1   
        }
        category: 4
        categoryDetail: "其他"
        createTime: "10:01"
    }, 
    {
        agent: {
            avatar: "https://"
            cityId: 1
            imCount: 1
            likeCount: 0
            liveness: 110
            replyRate: "0"
            role: 1   
        }
        category: 4
        categoryDetail: "其他"
        createTime: "10:01"
    },
    // 一共10条
]
```

>  要求：拿到有 agent 数据的对象，并且将 agent 中的数据和对象中原本的数据抽出来需要的部分组成一个 item，并且自定义名称，加到原有数组中

```js
				let data = res.data.list.filter(item => {
                    return item.agent // 过滤有 agent 的
                })
                let list = data.map(item => { 
                    return {
                        avatar: item.agent.avatar,
                        role: item.agent.role,
                        createTime: item.createTime
                    }
                })
                this.dynamicList.push(...list) // 加入到原来的数组中
```

## margin 写 3 个值

margin: 20px 40px 60px;（上20px；左、右40px；下60px）

## vscode 折叠展开代码

* 折叠所有区域代码的快捷： ctrl + k   ctrl + 0 ;

* 展开所有折叠区域代码的快捷：ctrl +k   ctrl + J ;

## 如何快速的删除 node_modules

`	rimraf node_modules`

## $nextTick

Vue 在更新 DOM 时是**异步**执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 `Promise.then`、`MutationObserver` 和 `setImmediate`，如果执行环境不支持，则会采用 `setTimeout(fn, 0)` 代替。

例如，当你设置 `vm.someData = 'new value'`，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 `Vue.nextTick(callback)`。这样回调函数将在 DOM 更新完成后被调用。例如：

```js
Vue.component('example', {
  template: '<span>{{ message }}</span>',
  data: function () {
    return {
      message: '未更新'
    }
  },
  methods: {
    updateMessage: function () {
      this.message = '已更新'
      console.log(this.$el.textContent) // => '未更新'
      this.$nextTick(function () {
        console.log(this.$el.textContent) // => '已更新'
      })
    }
  }
})
```

## 关于图片处理

正常一个竖屏的封面图，怎么截取中间部分作为封面呢？

**采用background属性设置**

```html
 <div class="imagecover" 
      :style="{'background-image': 'url(' + CoverUrl ')'}"></div>

<style>
	.imagecover {              
        width: 345px;
        height: 194px;
        overflow: hidden;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
    }
</style>
```

* background-size属性

```
cover
```

缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 `contain` 值相反，`cover` 值尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪。

```
contain
```

缩放背景图片以完全装入背景区，可能背景区部分空白。`contain` 尽可能的缩放背景并保持图像的宽高比例（图像不会被压缩）。该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。

## iterm2

* [iTerm2 + Oh My Zsh 打造舒适终端体验](https://zhuanlan.zhihu.com/p/37195261)

* [Mac上iterm2分屏切换](https://www.jianshu.com/p/4a27bb4c216c)