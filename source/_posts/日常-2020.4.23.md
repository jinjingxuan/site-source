---
title: 日常-2020.4.23
date: 2020-04-23 09:52:01
categories: 日常
---

* 虚拟DOM
* 小程序的页面栈
* 小程序的生命周期
* 一次踩坑经历（异步执行顺序）

<!--more-->

## vue的虚拟DOM

参考文章：[vue核心之虚拟DOM(vdom)](<https://www.jianshu.com/p/af0b398602bc>) ,[详解Vue中的虚拟DOM ](<https://www.cnblogs.com/fundebug/p/vue-virtual-dom.html> )

**真实DOM和解析流程**

>  创建DOM树——创建StyleRules——创建Render树——布局Layout——绘制Painting 

**JS操作真实DOM的代价**

> 原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。如果连续操作了10次DOM，前一次计算可能为无用功。计算DOM节点坐标值等都是白白浪费的性能。

**为什么需要虚拟DOM**

> 虚拟DOM就是为了**解决浏览器性能问题**而被设计出来的。**如前**，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。

也就是说，可以把虚拟DOM理解为一个简单的JS对象，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性,就比如像下面这样。

```js
const vnode = {
  tag:'div',
  attrs:{id:'app'},
  children:[{ tag:'span',attrs:{id:'child'},children:['1']}]
}
```

### Vue的渲染流程

![1](https://image.fundebug.com/2019-06-26-01.png)

 

- **渲染函数**：渲染函数是用来生成Virtual DOM的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制。
- **VNode 虚拟节点**：它可以代表一个真实的 dom 节点。通过 createElement 方法能将 VNode 渲染成 dom 节点。简单地说，vnode可以理解成**节点描述对象**，它描述了应该怎样去创建真实的DOM节点。
- **patch(也叫做patching算法)**：虚拟DOM最核心的部分，它可以将vnode渲染成真实的DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。

 为了实现高效的DOM操作，一套高效的虚拟DOM diff算法显得很有必要。**我们通过patch 的核心----diff 算法，找出本次DOM需要更新的节点来更新，其他的不更新**。 

- patch（补丁）：将虚拟DOM渲染成真实的DOM
- diff（差异）：比较新旧虚拟结点之间的不同

![2](https://image.fundebug.com/2019-06-26-04.png)

### diff算法

原理：两个树完全的diff算法的时间复杂度为O（n^3）,Vue进行了优化，只比较同级不考虑跨级，时间复杂度为O（n），步骤大致如下：

* 同级比较，再比较子结点
* 先判断一方有子节点，另一方没有的情况，直接更新
* 若都有子节点，递归比较

```js
function diff(vnode, newVnode) {
    var children = vnode.children || []
    var newChildren = newVnode.children || []
  // 遍历现有的children
    children.forEach(function (childVnode, index) {
        var newChildVnode = newChildren[index]
  // 两者tag一样
        if (childVnode.tag === newChildVnode.tag) {
            // 深层次对比，递归
            diff(childVnode, newChildVnode)
        } else { 
  // 两者tag不一样
           replaceNode(childVnode, newChildVnode) 
       }
    }
)}
```

然后我去看了一下源码中的diff算法，在`src/vdom/patch.js`中，说实话emmm，没看懂，等以后学到位了再详细看把，先在这记录一下。

## 小程序的页面栈

| 路由方式                             | 页面栈                                   |
| ------------------------------------ | ---------------------------------------- |
| 初始化                               | 新页面入栈                               |
| 打开新页面（wx.navigateTo）          | 新页面入栈                               |
| 页面重定向（wx.redirctTo）           | 当前页面出栈，新页面入栈                 |
| 页面返回（wx.navigateBack）          | 页面不断出栈，直到目标返回页，新页面入栈 |
| Tab切换（wx.switchTab或底部tab切换） | 页面全部出栈，只留下新的Tab页面          |
| 重启动（wx.relaunch）                | 页面全部出栈，只留下新的页面             |

* `navigateTo`, `redirectTo` 只能打开非 tabBar 页面。
* `switchTab` 只能打开 tabBar 页面。
* `reLaunch` 可以打开任意页面。
* 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。
* 调用页面路由带的参数可以在目标页面的`onLoad`中获取。

 ## 小程序的生命周期

```js]
onLaunch() {
  console.log('onLaunch监听小程序初始化');
}

onShow() {
  console.log('onShow监听小程序显示');
}

onHide() {
  console.log('onLaunch监听小程序隐藏');
}
```

## 页面的生命周期

```js
 onLoad(options) {
    console.log('onLoad监听页面加载');
  }

  onReady() {
    console.log('onReady监听页面初次渲染完成');
  }

  onShow() {
    console.log('onShow监听页面显示');
  }

  onHide() {
    console.log('onHide监听页面隐藏');
  }

  onUnload() {
    console.log('onUnload监听页面卸载');
  }
```

## 一次踩坑经历（异步执行顺序）

```js
getDataFromDb(){//从数据库中获取
    success:function(res){
        setData()//获取的值设置到页面中
        console.log('1')
    }
}

fn(){
    getDataFromDb()
    getData()//从页面中取值，发现取不到
    console.log('2')
}

//2,1
```



 

 

 

 