---
title: 日常-2020.3.11
date: 2020-03-11 09:52:01
categories: 日常
---

* 算法：手写快排
* 看一遍之前Node.js的博客
* Node.js串口通信与计步算法
* 关于WebSocket
* 关于前端性能优化
* 前端与编译原理

<!--more-->

## 1.算法：手写快排

```js
		   //快排的基本思想是分治，选择一个枢纽，小的放它左面，大的右面，这样pivot放在了最终位置
            //然后再对pivot左右两个子表排序
            //下面为一趟排序过程，以4为枢纽
            let arr = [4,7,6,5,3,2,8,1]
            function sort(arr){
                let low=0
                let high=arr.length-1
                let pivot = arr[low]
                while(low<high){
                    while(low<high&&arr[high]>=pivot) --high
                    arr[low] = arr[high]
                    while(low<high&&arr[low]<=pivot) ++low
                    arr[high] = arr[low]
                    console.log(arr)
                }
                arr[low]=pivot
            }
            sort(arr) //[1, 2, 3, 4, 5, 6, 8, 7]

//过程如下，最终小于4的在左面，大于4的在右面
// [4, 7, 6, 5, 3, 2, 8, 1]
// [1, 7, 6, 5, 3, 2, 8, 7]
// [1, 2, 6, 5, 3, 6, 8, 7]
// [1, 2, 3, 5, 5, 6, 8, 7]
// [1, 2, 3, 5, 5, 6, 8, 7]
// [1, 2, 3, 4, 5, 6, 8, 7]

//优化：
//1.子序列的规模较小时，不用在递归调用快排，可以采取直接插入排序
//2.尽量选一个可以将数据中分的枢纽元素，比如从序列的头，中，尾选3个，取这三个值的中间元素为枢纽
```

## 2.看一遍之前Node.js的博客

### （1）Nodejs区别于传统应用的特点：

1. 异步事件驱动：当异步函数执行时，不确定何时执行完毕，回调函数会被压入到一个事件循环队列，然后往下执行其他代码，直到异步函数执行完成后，才会开始处理事件循环，调用相应的回调函数。事件循环队列为先进先出队列，按顺序执行。 
2. 非堵塞I/O：Nodejs提供的很多模块中都是异步执行的。比如，文件操作的函数。 
3. 单线程（这里指主线程）
4. 性能出众：底层选择用c++和v8来实现的，上面第一点讲到过，nodejs的事件驱动机制，这意味着面对大规模的http请求，nodejs是凭借事件驱动来完成的，性能部分是不用担心的，并且很出色

### （2）Nodejs应用场景

适合I/O密集型的应用，如在线多人聊天，多人在线小游戏，实时新闻，博客，微博之类的。

不适合的场景有：cpu密集型的应用，如计算圆周率，视频解码等业务场景较多的。

### （3）什么是CPU密集与IP密集

CPU 密集的程序一般而言CPU占用率相当高，任务本身不太需要访问I/O设备 。

I/O 密集的程序一般CPU占用率较低。任务本身需要大量I/O操作 。比起阻塞IO要优秀的多。

## 3.Node.js串口通信与计步算法

```js
//开发板程序
void sendPacket()
{
    // 向Tcp服务器发送多个数据包
	sprintf(g_cBsdBuf, "\n\r\t%d,%d,%d\n\r", g_cAccX, g_cAccY, g_cAccZ);
    // 发送格式字符串的形式
    UART_PRINT("%s", g_cBsdBuf);
    // 发送数据包
    sl_Send(g_sockID, g_cBsdBuf, 40, 0 );
}

//串口通信
var SerialPort = require("serialport").SerialPort;  //引入模块
var portName = 'COM3'; //定义串口名
var serialPort = new SerialPort(
 "COM3", {
   baudRate: 9600,  //波特率
   dataBits: 8,    //数据位
   parity: 'none',   //奇偶校验
   stopBits: 1,   //停止位
   flowControl: false 
}, false); 
serialPort.open(function(error){ 
   if(error){ 
     console.log("打开端口"+portName+"错误："+error);
   }else{  
   	console.log("打开端口成功，正在监听数据中");
     serialPort.on('data',function(data){
     	console.log(data);
     })
   }
});
```

### 计步算法

我们已知，用户在水平步行运动中，与地面垂直和前进两个加速度会呈现周期性变化，图像类似于正弦曲线，而与前进方向垂直的方向的加速度变化并不会太大。所以我们可以通过对曲线的峰值进行检测计算和加速度阀值决策，即可实时计算用户运动的步数。因为用户在运动中可能用手平持设备，或者将设备置于口袋中。所以，设备的放置方向不定。为此，通过计算三个加速度的矢量长度，我们可以获得一条步行运动的类似于正弦曲线的轨迹。

在波形图中存在波峰和波谷，检测步数其实就是检测波峰或者波谷。每两次波峰或波谷即可算作用户走了一步，这是该算法的主要原理。但是我们需要解决无效波峰的问题，避免一些因素对计步的干扰。

无效波峰的产生有两种原因：

1. 低幅抖动：由于不确定因素，设备可能发生一些微小的抖动，虽然出现了波峰与波谷，但并不能计入步数，对于这一干扰我们可以设定阈值来解决。

2. 快频抖动：由于不确定因素，设备可能发生快速的抖动（不包括跑步状态），虽然存在波峰波谷而且阈值满足要求，但是数据并不满足正常人走路的频率，对于这一干扰我们可以设定时间间隔，也就是说相邻两步的时间间隔的至少大于某一数值，我们过滤掉其中的高频数据来解决。

## 4.关于WebSocket

```
Websocket是HTML5新增的一种全双工通信协议，客户端和服务端基于TCP握手连接成功后，两者之间就可以建立持久性的连接，实现双向数据传输。

socket是TCP/IP的封装，是一个接口。websocket是应用层的。
```

### 为什么要用 websocket

websocket 协议和 http 协议类似，http 协议有一个缺陷，只能由客户方端发起请求，服务端根据请求 url 和传过去的参数返回对应结果

websocket 是双向通信的，只要 websocket 连接建立起来，可以由客户端给服务端发送数据，也可以由服务端主动给客户端发送数据

## 5.关于前端性能优化

（1）雪碧图：将多张图片合并成一张图片后，下载全部所需的资源，只需一次请求。可以减小消耗 

（2）预加载：HTML5，prefetch预加载

**有了浏览器缓存，为何还需要预加载？**

- 用户可能是第一次访问网站，此时还无缓存
- 用户可能清空了缓存
- 缓存可能已经过期，资源将重新加载
- 用户访问的缓存文件可能不是最新的，需要重新加载

**Chrome 的预加载技术**

现在的 chrome 聪明到根据你的浏览记录，预测到你可能访问或搜索哪些网站，在你打开网站之前就加载好了一些资源了。
举个栗子，当你在搜索框输入 "amaz" 时，它猜测到你可能要访问 amazon.com，可能就帮你加载了这个网站的一些资源。
如果这个预测算法精准的话，就能大大地提高用户的浏览体验了。

**DNS prefetch**

我们知道，当我们访问一个网站如 www.amazon.com 时，需要将这个域名先转化为对应的 IP 地址，这是一个非常耗时的过程。

DNS prefetch 分析这个页面需要的资源所在的域名，浏览器空闲时提前将这些域名转化为 IP 地址，真正请求资源时就避免了上述这个过程的时间。

```
<meta http-equiv='x-dns-prefetch-control' content='on'>
<link rel='dns-prefetch' href='http://g-ecx.images-amazon.com'>
<link rel='dns-prefetch' href='http://z-ecx.images-amazon.com'>
<link rel='dns-prefetch' href='http://ecx.images-amazon.com'>
<link rel='dns-prefetch' href='http://completion.amazon.com'>
<link rel='dns-prefetch' href='http://fls-na.amazon.com'>
```

应用场景1：我们的资源存在在不同的 CDN 中，那提前声明好这些资源的域名，就可以节省请求发生时产生的域名解析的时间。
应用场景2：如果我们知道用户接下来的操作一定会发起一起资源的请求，那就可以将这个资源进行 DNS-Prefetch，加强用户体验。

**Resource prefetch**

在 Chrome 下，我们可以用 link标签声明特定文件的预加载：

```html
<link rel='subresource' href='critical.js'>
<link rel='subresource' href='main.css'>
<link rel='prefetch' href='secondary.js'>
```

在 Firefox 中或用 meta 标签声明：

```
<meta http-equiv="Link" content="<critical.js>; rel=prefetch">
```

rel='subresource' 表示当前页面必须加载的资源，应该放到页面最顶端先加载，有最高的优先级。

rel='prefetch' 表示当 subresource 所有资源都加载完后，开始预加载这里指定的资源，有最低的优先级。

注意：只有可缓存的资源才进行预加载，否则浪费资源！

**Prerender**

前面说到的预解析DNS、预加载资源已经够强悍了有木有，可还有更厉害的预渲染（Pre-rendering）！

预渲染意味着我们提前加载好用户即将访问的下一个页面，否则进行预渲染这个页面将浪费资源，慎用！

```
<link rel='prerender' href='http://www.pagetoprerender.com'>
```

rel='prerender' 表示浏览器会帮我们渲染但隐藏指定的页面，一旦我们访问这个页面，则秒开了！

在 Firefox 中或用 rel='next' 来声明

```
<link rel="next" href="http://www.pagetoprerender.com">
```

## 6.前端与编译原理

编译程序的逻辑结构：

对于编译型语言：词法分析，语法分析，语义处理，生成中间代码，代码优化，代码生成

对于解释型语言：通过词法分析和语法分析得到语法树后，就可以开始解释执行了。 

### （1）词法分析：

词法分析阶段的任务是对输入的符号串形式的源程序进行最初的加工处理。 将字符流转为token流。

```js
                 a[index] = 1*2;

                ( 1 )     a              标识符
	            ( 2 )     [              左方括号
	            ( 3 )    index           标识符	
	            ( 4 )     ]              右方括号
	            ( 5 )     =              赋值
	            ( 6 )     1              整常数
	            ( 7 )     *              乘号   	
	            ( 8 )     2              整常数
	            ( 9 )     ;              分号
```

### （2）语法分析：

对词法分析的结果进行语法检查, 并识别出单词序列所对应的语法范畴 。通常将语法分析的结果表示为分析树(parse tree)或语法树(syntax tree)。

### （3）预编译：

function函数”是一等公民！编译阶段，会把定义式的函数优先执行，也会把所有var变量创建，默认值为undefined，以提高程序的执行效率 

### （4）解释执行

```
做了一个小型的C语言编译器，当时做了词法分析，实现的就是输入一个txt源文件，输出xml格式的结果。
词法分析的是采用递归下降分析法，自己写了一些文法，但是范围不是很大。

语法分析分为：自下而上分析，自上而下分析

文法G=(Vn,Vt,P,Z)（grammar）
Vn：非终结符号集（nonterminal vocabulary）
Vt：终结符号集（V=Vn∪Vt，称为文法的字汇表）（terminal）
P：产生式或规则的集合（principle）
Z开始符号（识别符号）Z∈Vn
```