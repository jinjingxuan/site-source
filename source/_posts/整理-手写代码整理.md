---
title: 手写代码整理
date: 2020-03-20 09:52:01
categories: 面试
---

* 手写节流代码
* 手写防抖代码
* 手写柯里化
* 手写apply,bind,call
* 手写promise.all
* 手写promise.race

## 防抖

**在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms**，然后：

- 如果在200ms内没有再次触发滚动事件，那么就执行函数
- 如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时

```js
// 防抖debounce
function debounce(func, wait) {
  let timer = null;
  return function () {
    // 保存this和arguments是为了让debounce函数最终返回的函数this指向不变以及依旧能够接收到event参数。
    let context = this;
    let args = arguments;
    timer && clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, delay);
  }
}

function out(){
    console.log("防抖")
}
window.onscroll = debounce(out,1000)
```

## 节流

如果短时间内大量触发同一事件，那么**在函数执行一次之后，该函数在指定的时间期限内不再工作**，直至过了这段时间才重新生效。 

```js
function throttle(fn,delay){
    let lastTime = 0;
    return function () {
        let now = +new Date();
        if (now - lastTime > delay) {
            fn.apply(this, arguments);
            lastTime = now;
        }
    }
}
function out(){
    console.log("节流")
}
window.onscroll = throttle(out,1000)
```

## 柯里化，apply，call，bind，promise

```js
        //柯里化
        let curry = (fn,...args)=>
            args.length<fn.length
                ?(...arguments)=>curry(fn,...args,...arguments)
                :fn(...args)
        //apply
        Function.prototype.myApply = function(thisArg,rest){
            thisArg = thisArg || window
            thisArg.func = this
            if(!rest){
                let result = thisArg.func()
            }else{
                let result = thisArg.func(...rest)
            }
            delete thisArg.func
            return result
        }
        //call
        Function.prototype.myCall = function(){
            let [thisArg,...args] = [...arguments]
            thisArg = thisArg || window
            thisArg.func = this
            let result = thisArg.func(...args)
            delete thisArg.func
            return result 
        }
        //bind
        Function.prototype.myBind = function(){
            let [thisArg,...args] = [...arguments]
            let that = this
            return ()=>{
                return that.call(thisArg,...args,...arguments)
            }
        }
        //promise.all
        Promise.all = function(promises){
            return new Promise((resolve,reject)=>{
                let result = []
                let len = promises.length
                let index = 0
                if(len==0){
                    resolve(result)
                }
                for(let i=0;i<len;i++){
                    Promise.resolve(promise[i]).then((res)=>{
                        result[i] = res
                        index++
                        if(index==len){
                            resolve(result)
                            return
                        }
                    }).catch((err)=>{
                        reject(err)
                    })
                }
            })
        }
        //promise.race
        Promise.race = function(promises){
            return new Promise((resolve,reject)=>{
                let len = promises.length
                if(len==0) return
                for(let i=0;i<len;i++){
                    Promise.resolve(promises[i]).then(res=>{
                        resolve(res)
                        return
                    }).catch((err)=>{
                        reject(err)
                        return 
                    })
                }
            })
        }
```

