---
title: 面试题（三）
date: 2018-08-04 09:21:01
categories: 面试
---

* == 和 === 的区别
* 讲讲 js 的继承方式
* 介绍一下箭头函数
* this 的指向
* 简述CSS选择器的优先级规则
* 简述居中一个元素的方法
* 浏览器缓存和webpack缓存配置
* meta标签与视口

## == 和 === 的区别

> == 代表相同， ===代表严格相同
>
> 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false.
>
> null == undefined // true，是一种规定
> null === undefined // false
>
> typeof null // object
> typeof undefined // undefined

## 讲讲 js 的继承方式

**（1）原型链继承：子类原型是对父类的实例化**

```js
function Father(){}
function Son(){}
Son.prototype = new Father()   //实例化对象会指向父类的原型，如图
```

![原型链继承](http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/public/16-11-11/5352248.jpg)

缺点：

1.父类的共有属性会被子类实例共享

2.创建子类对象无法传参，因为只有Son.prototype = new Father()可以传，但是会对所有子类有效。

**（2）构造函数继承**

```js
function Father(name,age){
    this.name = name;
    this.age = age;
}
function Son(name,age,sex){
    this.sex = sex;
    Father.call(this,name,age)
}
var son1 = new Son('张三','30','男')

//简述new一个对象的过程
//1.创造一个新的空对象
//2.新对象的_proto_指向构造函数的原型对象
//3.构造函数的this指向正在创建的新对象，并执行构造函数的代码，向新对象中添加属性和方法。
//4.返回新对象地址

//讲一下_proto_和prototype的区别
//1.__proto__是 对象实例 都有的，而 prototype 是函数对象特有的
//2.prototype 原型对象 有 constructor 属性，又指回 构造函数
//3.对象实例的 __proto__ 均默认指向 它们的 构造函数的 prototype
```

缺点： 

 1.父类的原型方法不会被子类继承，如果全放到构造函数中，每个子类实例都单独拥有一份，违反复用性。

 2.不能通过 son instanceof Father

**（3）组合继承**

```js
function Father(name,age){
    this.name = name;
    this.age = age;
}
function Son(name,age,sex){
    this.sex = sex;
    Father.call(this,name,age)
}
Son.prototype = new Father()
```

缺点：父类的构造函数执行了两遍

**（4）原型式继承：对原型链继承的封装**

```js
function inheritObject(o){
    function F(){}
    F.prototype = o;
    return new F();
}
var book = {
    name:'js book'
}
var newBook = inheritObject(book)
var newBook.name = 'ajax book'
```

缺点：仍存在原型链继承的缺点

优点：F中无内容，开销比较小。

**（5）寄生式继承：对原型继承的二次封装并进行了扩展**

```js
var book = {
    name:'js book'
}
function creteBook(obj){
    var o = inheritObject(obj); //不仅有父类中的属性和方法
    //扩展新对象
    o.getName = function(){     //还添加了新的属性和方法
        console.log(name)
    }
    return o
}
```

缺点：方法在函数中定义，无法得到复用

**（6）寄生组合继承（最理想）**

组合继承= 原型链继承 + 构造函数继承

寄生组合式继承=寄生式继承+构造函数继承

```js
function inheritObject(o){
    function F(){}
    F.prototype = o;
    return new F();
}
function inheritPrototype(subClass,superClass){
    var p = inheritObject(superClass.prototype)
    p.constructor = subClass
    subClass.prototype = p
}
//父类
function SuperClass(name){
    this.name = name
}
//子类
function SubClass(name,time){
    //构造函数式继承
    SuperClass.call(this,name)
    this.time = time
}
//寄生式继承父类原型
inheritPrototype(subClass,superClass)
```

## 介绍一下箭头函数

箭头函数的含义

```js
x => x * x  // 相当于
function (x) {
    return x * x;
}
```

- 说一下箭头函数和普通函数的区别

（1）箭头函数是匿名函数，不能作为构造函数，不能使用new
（2）箭头函数不绑定arguments，取而代之用rest参数…解决

```js
let B = (b)=>{
	console.log(arguments);
}
B(2,92,32,32); // Uncaught ReferenceError: arguments is not defined

let C = (...c) => {
  console.log(c);
}
C(3,82,32,11323);  // [3, 82, 32, 11323]   
```

（3）箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值
（4）箭头函数通过 call() 或 apply() 方法调用一个函数时，对 this 并没有影响。
（5）箭头函数没有原型属性

## this 的指向

- 普通函数指向函数调用者（执行的时候才确定）
- 箭头函数指向函数所在的作用域（对象的{}和if(){}都构不成作用域）

```js
const obj = {
    name:'objName',
    say:function(){console.log(this.name)},
    read:()=>{console.log(this.name)}
}
obj.say();  //objName     指向的是调用者
obj.read(); //undefined   指向的是window.name
```

怎么答：

1. 全局环境中的this指向全局对象window
2. new绑定，并且构造函数没有**返回其他对象**，this指向这个新对象
3. 通过call，apply，bind，并且第一个参数值不是Null,undefined，那么this绑定的就是指定的对象
4. 普通函数指向函数调用者（执行的时候才确定）
5. 箭头函数指向函数所在的作用域，根据上下文确定

关于第二条

```js
function fn()  
{  
    this.user = '追梦子';  
    return {};  
}
var a = new fn;  
console.log(a.user); //undefined
```

## 简述CSS选择器的优先级规则

> 优先级不同，高优先级属性覆盖低优先级属性
> 优先级相同，定义在后覆盖定义在先
>
> 内联 > ID选择器 > 类选择器 > 标签选择器，伪类>元素标记  !important最高，但是在低版本IE有兼容性问题

## 简述居中一个元素的方法

考虑：水平还是垂直，块还是行内，是否需要知道宽高，兼容性

（1）水平：

```js
1. 块元素：margin:0,auto
2. 行内元素，行内块元素：text-align:center
```

（2）垂直：

3. 行内元素：line-height：xxpx

4. 行内块元素：line-height：xxpx；vertical-align：middle

（3）水平竖直同时居中

 absolute方法：

5. 已知宽高：负数margin

```css
.parent{
    position: relative;
}
.child{
    position: absolute;
    top: 50%;
    left: 50%;
    width: 80px;
    height: 60px;
    margin-left: -40px;
    margin-top: -30px;
}
```

6. 已知宽高：calc

```css
.parent{
    position:relative;
}
.child{
    position:absolute;
    width: 80px;
    height: 60px;
    top:calc(50% - 30px);
    left:calc(50% - 40px);
}
```

7. 需要设定宽高：margin auto

```css
    .f14 .parent{
        position: relative;
    }
    .f14 .child{
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        height: 50px;
        width: 80px;
        margin: auto;
    }
```

8. 不需要设定宽高：transform(css3,IE8及以下不支持)

```css
    .f15 .parent{
        position: relative;
    }
    .f15 .child{
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);  自身偏移
    }
```

9. flex布局

```css
.main{
     display: flex;
     justify-content: center;
     align-items: center;
 }
```

10. table-cell + inline-block

css新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中，这个属性和table标签一样的居中原理。

```css
.parent{
    display: table-cell;
    text-align: center;
    vertical-align: middle;
}
.child{
    display: inline-block;
}
```

## 浏览器缓存和webpack缓存配置

* [浏览器缓存](https://juejin.cn/post/6844903763665240072)
* [hash、chunkhash和contenthash区别](https://www.jiangruitao.com/webpack/hash-chunkhash-contenthash/)

## meta标签与视口

首先介绍3个视口的概念

- **layout viewport(布局视口)：**在PC端上，布局视口等于浏览器窗口的宽度。而在移动端上，由于要使为PC端浏览器设计的网站能够完全显示在移动端的小屏幕里，此时的布局视口会远大于移动设备的屏幕，就会出现滚动条。js获取布局视口：`document.documentElement.clientWidth | document.body.clientWidth`；
- **visual viewport(视觉视口)：**用户正在看到的网页的区域。用户可以通过缩放来查看网站的内容。如果用户缩小网站，我们看到的网站区域将变大，此时视觉视口也变大了，同理，用户放大网站，我们能看到的网站区域将缩小，此时视觉视口也变小了。不管用户如何缩放，都不会影响到布局视口的宽度。js获取视觉视口：`window.innerWidth`；
- **ideal viewport(理想视口)：**布局视口的一个理想尺寸，只有当布局视口的尺寸等于设备屏幕的尺寸时，才是理想视口。js获取理想视口：`window.screen.width`；
- 页面的滚动条取决于视觉视口和布局视口，页面元素宽度取决于布局视口大小

我们在开发时，常常加入这样一行代码

```html
<meta content="width=device-width, initial-scale=1.0" name="viewport">
```

- `width=device-width`，这句代码的意思就是把布局视口 = 理想视口。
- `initial-scale`指的是缩放系数。其中有这样的公式：

```js
视觉视口宽度 = 理想视口宽度 / 缩放系数 

比如iphone加入这段代码时：
视觉视口 = 320/1.0 = 320
布局视口 = 320
当视觉视口= 布局视口，页面无滚动条。

当改变initial-scale时：

initial-scale = 0.5 
视觉视口宽度 = 320 / 0.5 = 640
布局视口宽度 = 320
又因为：视觉视口不能大于布局视口，所以此时，将布局视口的宽度提高等于640
总结：视觉视口 = 布局视口 = 640

initial-scale = 2 「 div宽度320，页面有滚动条 」
视觉视口宽度 = 320 / 2 = 160
布局视口宽度 = 320
总结：视觉视口 < 布局视口 页面出现了滚动条。
```