---
title: 抽象工厂模式
date: 2019-1-21 16:00:54
categories: 设计模式
---

# 抽象工厂模式

抽象工厂模式：通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例。

JS中是没有直接的抽象类的，abstract是个保留字，但是还没有实现，因此我们需要在类的方法中抛出错误来模拟抽象类，如果继承的子类中没有覆写该方法而调用，就会抛出错误。

```js
var Car = function() { }
Car.prototype = {
    getPrice : function() {
        return new Error('抽象方法不能调用');
    },
    getSpeed : function() {
        return new Error('抽象方法不能调用');
    },
}
```

<!--more-->

面向对象的语言里有抽象工厂模式，首先声明一个抽象类作为父类，以概括某一类产品所需要的特征，继承该父类的子类需要实现父类中声明的方法而实现父类中所声明的功能：

```js
	    //抽象工厂方法
		var VehicleFactory = function(subType,superType){
			//判断抽象工厂中是否有该抽象类
			if(typeof VehicleFactory[superType] === 'function'){
				//缓存类
				function F(){};
				//继承父类的属性与方法
				F.prototype = new VehicleFactory[superType]();
				//将子类constructor指向子类
				subType.construstor = subType;
				//子类原型继承父类
				subType.prototype = new F();
			}else{
				//不存在该抽象类抛出错误
				throw new Error('未创建该抽象类');
			}
		}
		//小汽车抽象类
		VehicleFactory.Car = function(){
			this.type = 'car';
		};
		VehicleFactory.Car.prototype = {
			getPrice : function() {
		        return new Error('抽象方法不能调用');
		    },
		    getSpeed : function() {
		        return new Error('抽象方法不能调用');
		    }
		};
		//公交车抽象类
		VehicleFactory.Bus = function(){
			this.type = 'bus';
		};
		VehicleFactory.Bus.prototype = {
			getPrice : function() {
		        return new Error('抽象方法不能调用');
		    },
		    getSpeed : function() {
		        return new Error('抽象方法不能调用');
		    }
		};
		//货车抽象类
		VehicleFactory.Truck = function(){
			this.type = 'truck';
		};
		VehicleFactory.Truck.prototype = {
			getPrice : function() {
		        return new Error('抽象方法不能调用');
		    },
		    getSpeed : function() {
		        return new Error('抽象方法不能调用');
		    }
		};
```

抽象工厂其实是实现子类继承父类的方法，对抽象工厂添加抽象类也很特殊，因为抽象工厂是个方法不需要实例化对象，故只需要一份，因此直接为对象添加类的属性即可，于是我们就可以通过点语法在抽象工厂上添加我们一会儿需要的三个汽车簇抽象类Car,Bus,Truck。那我们该如何使用呢？

```js
		//奔驰汽车子类
		var BenzTruck = function(price,trainLoad){
			this.price = price;
			this.trainLoad = trainLoad;
		}
		//抽象工厂实现对Truck抽象类的继承
		VehicleFactory(BenzTruck,'Truck')
		BenzTruck.prototype.getPrice = function(){
			return this.price;
		}
		BenzTruck.prototype.getTrainload = function(){
			return this.trainLoad;
		}

		//测试
		var truck = new BenzTruck(100000,1000);
		console.log(truck.getPrice());     //100000
		console.log(truck.type);           //truck
```

