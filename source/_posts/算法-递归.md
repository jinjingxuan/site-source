---
title: 递归
date: 2020-08-03 10:27:54
categories: 算法
---

* 合并有序链表
* 最长公共子序列与最长公共子串
* 相同的树
* 判断二叉树是否对称
* 求二叉树深度
* 有序数组转二叉搜索树

## 合并有序链表（递归）

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

> 输入：1->2->4, 1->3->4
>
> 输出：1->1->2->3->4->4

递归思想：比较第一个值，取小的，依次递归

```js
var mergeTwoLists = function(l1, l2) {
    if(l1==null) return l2
    if(l2==null) return l1
    if(l1.val<=l2.val){
        l1.next = mergeTwoLists(l1.next,l2)
        return l1
    } else{
        l2.next = mergeTwoLists(l1,l2.next)
        return l2
    }
};
```

## 最长公共子序列和最长公共子串

> A:"helloworld"    B="loop"    
> 最长公共子序列:loo
> 最长公共子串 ：lo （必须连续）
>
> 最长公共子序列：
>  输入: X=x1x2…xn, Y=y1y2…ym,  输出: X和Y的LCS 
>  定义: c[i][j] = Xi,Yj的LCS长度(OSP) 

![3btMhq.png](https://s2.ax1x.com/2020/03/06/3btMhq.png)

> 最长公共子串类似
> xi=yj，c[i][j]=c[i-1][j-1]+1，很显然，当比对的位字符一样时，能得到该状态转移方程。
> xi≠yj，c[i][j]=0，说明无论之前有没有连续的子串，到了这个不相等的位置会直接断掉，所以c[i][j]=0;

## 相同的树

> 给定两个二叉树，编写一个函数来检验它们是否相同。
>
> 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
>
> 示例 1:
>
> 输入:  1         1
>           / \       / \
>          2   3     2   3
>
> [1,2,3],   [1,2,3]
>
> 输出: true
> 示例 2:
>
> 输入: 1          1
>           /           \
>          2             2
>
> [1,2],     [1,null,2]
>
> 输出: false
> 示例 3:
>
> 输入:  1         1
>           / \       / \
>          2   1     1   2
>
>   [1,2,1],   [1,1,2]
>
> 输出: false

```js
var isSameTree = function(p, q) {
    if(p == null && q==null) return true
    else if((p==null&&q!==null) || (p!==null&&q==null)) return false
    else if(p.val!==q.val) return false
    else return isSameTree(p.left,q.left) && isSameTree(p.right,q.right)
};
```

## 判断二叉树是否对称

> 给定一个二叉树，检查它是否是镜像对称的。
>
>  
>
> 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
>
> ​    1
>
>    / \
>   2   2
>  / \ / \
> 3  4 4  3
>
>
> 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
>
> ​    1
>
>    / \
>   2   2
>    \   \
>    3    3

* 和上题类似，把根节点拿掉，就是判断两个树的关系

```js
var isSymmetric = function(root) {
    if(root === null) return true

    var p = root.left
    var q = root.right

    function fn(p,q){
        if(p==null&&q==null) return true
        else if((p!==null&&q==null)||(p==null&&q!==null)) return false
        else if(p.val!==q.val) return false
        else return (fn(p.left,q.right)&&fn(p.right,q.left))
    }
    
    return fn(p,q)
};
```

## 求二叉树深度

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> 说明: 叶子节点是指没有子节点的节点。
>
> 示例：
> 给定二叉树 [3,9,20,null,null,15,7]，
>
> ​    3
>
>    / \
>   9  20
>     /  \
>    15   7
> 返回它的最大深度 3 。

* 递归思想

```js
var maxDepth = function(root) {
    if(!root) return 0
    else{
        let left = maxDepth(root.left)
        let right = maxDepth(root.right)
        return Math.max(left,right) + 1
    }
};
```
## 有序数组转二叉搜索树

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

> 给定有序数组: [-10,-3,0,5,9],
>
> 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
>
> ​       0
> ​      / \
>
>    -3   9
>    /   /
> -10  5

- 每次取中间的值作为根节点

```js
var sortedArrayToBST = function(nums) {
    if(nums.length === 0) return null
    let mid = parseInt(nums.length / 2)
    let root = new TreeNode(nums[mid])
    root.left = sortedArrayToBST(nums.slice(0, mid))
    root.right = sortedArrayToBST(nums.slice(mid + 1))
    return root
};

// parseInt(nums.length / 2)      =>     nums.length >> 1
```



   -