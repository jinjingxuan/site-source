---
title: 贪心
date: 2020-10-28 16:00:54
categories: 算法
---

* 贪心算法
* 移掉 k 位数字
* 非递增顺序的最小子序列

## 贪心算法

贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。

**贪心算法一般按如下步骤进行： **

①建立数学模型来描述问题 。

②把求解的问题分成若干个子问题。

③对每个子问题求解，得到子问题的局部最优解 。

④把子问题的解局部最优解合成原来解问题的一个解  。

```js
贪心算法是一种对某些求最优解问题的更简单、更迅速的设计技术。贪心算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，省去了为找最优解要穷尽所有可能而必须耗费的大量时间。贪心算法采用自顶向下，以迭代的方法做出相继的贪心选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题，通过每一步贪心选择，可得到问题的一个最优解。虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪心算法不要回溯
```

**存在的问题**

- 不能保证求得的最后解是最佳的
- 不能用来求最大值或最小值的问题
- 只能求满足某些约束条件的可行解的范围

## 移掉 k 位数字

具体看 [算法-栈](https://www.jinjingxuan.com/2020/10/22/%E7%AE%97%E6%B3%95-%E6%A0%88/#more) 中的最后一题

## 非递增顺序的最小子序列

* [leetcode1403](https://leetcode-cn.com/problems/minimum-subsequence-in-non-increasing-order)

```js
给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。

如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。

与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。

注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。


示例 1：
输入：nums = [4,3,10,9,8]
输出：[10,9] 
解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 

示例 2：
输入：nums = [4,4,7,6,7]
输出：[7,7,6] 
解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  

示例 3：
输入：nums = [6]
输出：[6]
```

* 数组从大到小排序
* 取出最大值放入 ans 中，如果不选这个最大值将不是最优解，选了之后继续进行下一步子问题的选择(贪心)
* 直到取出元素大于所有元素和的一半为止

```js
var minSubsequence = function(nums) {
    let sum = 0
    let tmp = 0
    let ans = []
    for (let i of nums) {
        sum += i
    }
    nums.sort((a, b) => b - a)
    for (let i = 0; i < nums.length; i++) {
        tmp += nums[i]
        if (tmp * 2 > sum) {
            ans = nums.slice(0, i + 1)
            return ans
        }
    }   
};
```

