---
title: 面试题（十）
date: 2018-08-03 09:21:01
categories: 面试
---

* call, apply, bind 的区别？怎么实现
* 介绍一下vue的生命周期
* 16进制颜色转换为rgb
* keep-alive了解吗
* Vue中组件生命周期调用顺序
* 你都做过哪些Vue的性能优化
* npm install 原理

## call, apply, bind 的区别？怎么实现

> 都是用来改变函数的 this 对象的指向的。
>
> 第一个参数都是 this 要指向的对象。
>
> 都可以利用后续参数传参。 区别：
>
> call 接受函数传参方式为：fn.call(this, 1, 2, 3)
>
> apply 接受函数传参方式为：fn.apply(this,[1, 2, 3])
>
> bind 的返回值为一个新的函数，需要再次调用： fn.bind(this)(1, 2, 3)

* [手写代码整理](https://www.jinjingxuan.com/2020/03/20/%E6%95%B4%E7%90%86-%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/)

## vue的生命周期

### beforeCreate( 创建前 )

使用这个钩子，组件的选项对象并没有创建，el和data都还没初始化，所以data、methods和computed等都用不了。一般用来在组件挂在之前渲染一些东西。

### created ( 创建后 ）

这时候上面的data、methods、computed都已经创建完成了，数据观测，属性和方法的运算，watch/event事件回调都完成了，但这时候挂载阶段mount还没开始，是el并没有完成。这是最常用的生命周期钩子，可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也在这里发ajax请求，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter（路由守卫）中完成

### beforeMount（挂载之前）

挂载之前被调用，render（渲染）函数首次被调用（虚拟DOM），这里已经完成了模板编译，data里面的数据和模板会生产HTML，这里el也完成了，但并没有挂载到html页面上。

### mounted（挂载）

挂载完成了，这时候HTML模板会被渲染到HTML中，还可以做一些ajax操作。但mounted只能执行一次。

### beforeUpdate（更新之前）

更新指数据更新，发生在虚拟DOM重新渲染和补丁之前，在这个钩子中可以更改状态而不发生重绘。

### updated（更新后）

在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用

### beforeDestroy（销毁前）

在实例销毁前调用，但实例还可以用。

这里还可以使用this，一般用来做重置操作，比如清除定时器和DOM监听事件。

### destroyed（销毁后）

在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用

## 16进制颜色转换为rgb

```js
function hex2rgb(hex) {
	const str = hex.slice(1),
		res = []
	if (str.length === 3) {
		for (const w of str) {
			res.push(parseInt(w + w, 16))
		}
	} else {
		for (let i = 0; i < 6; i += 2) {
			res.push(parseInt(str[i] + str[i + 1], 16))
		}
	}
	return res
}
```

## keep-alive了解吗

> keep-alive是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

### 一个场景

用户在某个列表页面选择筛选条件过滤出一份数据列表，由列表页面进入数据详情页面，再返回该列表页面，我们希望：列表页面可以保留用户的筛选（或选中）状态。keep-alive就是用来解决这种场景。当然keep-alive不仅仅是能够保存页面/组件的状态这么简单，它还可以避免组件反复创建和渲染，有效提升系统性能。 总的来说，keep-alive用于保存组件的渲染状态

> `keep-alive`可以实现组件缓存，当组件切换时不会对当前组件进行卸载。
>
> 常用的两个属性`include/exclude`，允许组件有条件的进行缓存。
>
> 两个生命周期`activated/deactivated`，用来得知当前组件是否处于活跃状态。
>
> keep-alive的中还运用了`LRU(Least Recently Used)`算法。

* [Vue keep-alive深入理解及实践总结](https://juejin.cn/post/6844903919273918477)

## Vue中组件生命周期调用顺序

组件的调用顺序都是`先父后子`,渲染完成的顺序是`先子后父`。

组件的销毁操作是`先父后子`，销毁完成的顺序是`先子后父`。

### 加载渲染过程

```js
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount- >子mounted->父mounted
```

### 子组件更新过程

```js
父beforeUpdate->子beforeUpdate->子updated->父updated
```

### 父组件更新过程

```js
父 beforeUpdate -> 父 updated
```

### 销毁过程

```js
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
```

## 你都做过哪些Vue的性能优化

* 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
* v-if和v-for不能连用
  * 当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级（vue3中反了过来）
  * 哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化。
  * 具体看[这篇文章](https://juejin.cn/post/6844904052371767309)

* SPA 页面采用keep-alive缓存组件
* [v-if与v-show](https://www.jinjingxuan.com/2018/08/03/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E5%85%AB%EF%BC%89/)
* key保证唯一
* [使用路由懒加载、异步组件](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E6%8A%8A%E7%BB%84%E4%BB%B6%E6%8C%89%E7%BB%84%E5%88%86%E5%9D%97)
* 防抖、节流
* 第三方模块按需导入
* 长列表滚动到可视区域动态加载
* 图片懒加载

## npm install 原理

[npm install 原理分析](https://cloud.tencent.com/developer/article/1555982)

