---
title: 日常-2020.3.31
date: 2020-03-31 09:52:01
categories: 日常
---

# 今日清单

* px,em,rem的区别
* 设备（物理）像素和CSS（逻辑）像素
* transform都有什么值
* 结构性伪类元素
* css实现奇数行蓝，偶数行红
* 99乘法表
* 1px细线
* css定位有哪几种，如果在一个文档流中给一个div定位fixed，不加left，top，它的位置在哪 
* promise封装setInterval
* 清除浮动
* 数据结构，最大堆、最小堆，能写堆排序吗 
* 快排的思想，能不能写写 

<!--more-->

## 1.px,em,rem的区别 

### （1）px

在Web页面初期制作中，我们都是使用“px”来设置我们的文本，因为他比较稳定和精确。但是这种方法存在一个问题，当用户在浏览器中浏览我们制作的Web页面时，他改变了浏览器的字体大小，这时会使用我们的Web页面布局被打破。 于是就有了em

### （2）em

em是相对长度单位。它的单位长度是根据元素的文本垂直长度来决定的。可以作用在width、height、line-height、margin、padding、border等样式的设置上。 如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 默认1em=16px。如果在body选择器中声明font-size=62.5%,则1em=10px。

```html
<style>
	.parent{ 
			font-size:5em; /*80px*/
			height:10em;/*800px*/
	}
    .child{
			font-size:2em;/*160px*/
			height:2em;/*320px*/
	}
</style>
<body>
	<div class="parent">
    <footer class="child">
        <div class="wrapper">
        </div>
    </footer>
</div>
```

在不设置元素font-size的情况下，em总是根据父元素的font-size来确定长度；即使元素设置了font-size，多次嵌套使用em也往往会造成疏忽，不仅使用前需要大量计算，而且不能保证没有漏网之鱼。这将是一个繁杂而低效率的工作。 于是有了rem.

### （3）rem

rem不是依据父元素——而是依据根元素（root element）来确定其长度。

我们一般给根元素设置一个容易计算的font-size

```
<style>
    html {
        font-size: 62.5%;   /* 10px */
    }
    div {
        font-size: 2.4rem;  /* 24px */
        width: 64rem;   /* 640px */
        border: 0.1rem solid #ccc;  /* 1px */
    }
</style>
<body>
    <div class="div1">
        <div class="div2">
        </div>
    </div>
</body>
```

## 2. 设备（物理）像素和CSS（逻辑）像素 

- 设备像素又称为物理像素, 是"物理屏幕"上真实存在的发光点，只有屏幕一经出厂就固定不会改变
- CSS像素又称为逻辑像素，是编程世界中虚拟的东西, 我们通过代码设置的像素都是逻辑像素
- 在PC端，1个CSS像素往往都是对应着电脑屏幕的1个物理像素,

```
在手机端，最开始其实1个CSS个像素也是对应着手机屏幕的1个物理像素,

但是后来一个改变世界的男人(乔布斯)改变了这一切~

从iPhone4开始，苹果公司推出了所谓的retina视网膜屏幕。

iPhone4的屏幕尺寸却没有变化，但是像素点却多了一倍

这就导致了在1个CSS像素等于1个物理像素的手机上, 我们设置1个CSS像素只会占用1个物理像素

而在1个CSS个像素不等于1个物理像素的手机上, 我们设置1个CSS像素就会占用2个物理像素

所以仔细观察你会发现同样是1像素但是在retina视网膜屏幕的手机上会粗一些
```

## 3.transform有什么值

`transform: rotate | scale | skew | translate |matrix;`

* transform:rotate(30deg)

* scale(x,y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）；

  scaleX(x)元素仅水平方向缩放（X轴缩放）；

  scaleY(y)元素仅垂直方向缩放（Y轴缩放）

* skew(x,y)使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形）；

  skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形）；

  skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形），

* translate:同样有三种方法

* matrix

## 4.结构性伪类元素

结构性伪类选择器的公共特征是允许开发者根据文档结构来指定元素的样式。 

**（1）nth-child和nth-last-child** 

```
 	  p:nth-child(n){background:red}  表示E父元素中的第n个字节点
      p:nth-child(odd){background:red}/*匹配奇数行*/
      p:nth-child(even){background:red}/*匹配偶数行*/
      p:nth-child(2n){background:red}/*其中n是从0开始计算*/
```

**（2）E:first-child和E:last-child** 

**（3）nth-of-type(n) 和E:nth-last-of-type(n)** 

**（4）**）E:root（根节点）、E:only-child（独子元素）、E:only-of-type（独子类型元素）和E:empty（孤节点） 

## 5.css实现奇数行蓝，偶数行红

```html
 <style>
        div{
            width: 200px;
            height: 200px;
        }
        div:nth-child(odd){
            background-color: blue;
        }
        div:nth-child(even){
            background-color: red;
        }
</style>

<body>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
</body>
```

## 6. 99乘法表

```html
	<style>
        body{
            text-align: center;
        }
        div{
            display: inline-block;
            width: 100px;
            height: 30px;
            margin-left:-1px;
            margin-top:-1px;
            border: 1px solid #000;
        }
    </style>  

    <script>
        for(let i=1;i<10;i++){
            for(let j=1;j<=i;j++){
                let div = document.createElement('div')
                document.body.appendChild(div)
                div.innerHTML=(j+"*"+i+"="+j*i)
            }
            document.write("<br>")
        }
    </script>
```

## 7. 1px的细线如何实现

1 用小数px值

2 border-image

3 background渐变

4 transform scale(0.5)

## 8.css定位有哪几种，如果在一个文档流中给一个div定位fixed，不加left，top，它的位置在哪 

问题同position的属性，举个例子看看。

## 9.promise能封装setInterval吗

不能，因为promise只能执行一次

```js
		  new Promise(function(resolve,reject){
                setTimeout(function(){
                    resolve()
                },1000)
            }).then(function(){
                console.log(1)
            })

            new Promise(function(resolve,reject){
                setInterval(function(){
                    resolve()
                },1000)
            }).then(function(){
                console.log(2)
            })
```

解决办法

```js
		   function p(){
                return new Promise(function(resolve,reject){
                    setTimeout(function(){
                        resolve()
                    },1000)
                }).then(function(){
                    console.log("1")
                })
            }
            setInterval(p,1000)
```

## 10.清除浮动

* #### 父级添加overflow: hidden；

* #### 通过属性clear:both;达到清除浮动的目的

元素浮动后，只需要在浮动元素添加多一个块级元素，并添加clear: both;属性，便可以达到清除浮动的目的。 

```html
<div style="clear: both;"></div>
```

* #### 通过给父级元素添加伪类after，达到清除浮动的目的；

```css
.div1:after{
            content: '';
            display: block;
            clear: both;
}
```

## 11.堆排序

堆排序是一种树形选择排序方法，将L[1...N]视为一棵完全二叉树的结构。

小根堆：`L[i]<=L[2i]且L[i]<=L[2i+1]`

大根堆：`L[i]>=L[2i]且L[i]>=L[2i+1]`

堆排序的关键是构造初始堆，对第[n/2]的结点进行筛选调整，依次筛选到1结点

```js
//建立大根堆
function BulidMaxHeap(arr,len){
    for(let i=len/2;i>0;i--){
        AdjustDown(arr,i,len)
    }
}
function AdjustDown(arr,k,len){
	
}
```

建成初始堆后，输出堆顶元素，然后通常将堆底元素送入堆顶，继续调整。

时间复杂度O(log2n)，不稳定