---
title: 刷题小分队
date: 2021-02-01 16:00:54
categories: 刷题
---

## 字符串解码

* [leetcode394](https://leetcode-cn.com/problems/decode-string/)

```js
示例 1：
输入：s = "3[a]2[bc]"
输出："aaabcbc"

示例 2：
输入：s = "3[a2[c]]"
输出："accaccacc"

示例 3：
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"

示例 4：
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

* 采用正则表达式将`3[a]` 的格式转换成`aaa`即可
* 匹配到`3[a]`之后，找到`[`的位置，前面为数字，后面为字符，按次数拼接

```js
var decodeString = function(s) {
    const reg = /\d+\[[a-z]+\]/g
    while (reg.test(s)) {
        s = s.replace(reg, item => {
            let pos  = item.indexOf('[') ,number = item.slice(0, pos)
            let str = item.slice(pos + 1, item.length - 1), res = ''
            for (let i = 0; i < number; i++) res += str
            return res
        })
    }
    return s
};
```

## 买卖股票的最佳时机

* [leetcode121](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```js
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票。

示例 1:
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
     
示例 2:
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

> 设 `dp[i]`为`i`支股票的最大利润，若已知前`i-1`支股票的最大利润为 `dp[i-1]`，怎么建立动态转移方程？
>
> 如果记录了前`i-1`支股票的最小值 min，那么最大利润一定是第`i`支股票的价格减去min所得的值与`dp[i-1]`之间的最大值，所以只需计算一下 `price[i] - min` 与` dp[i]` 的最大值

* 动态规划的三要素：最优子结构，边界，状态转移方程
* `dp[i]` 的 最优子结构就是 `dp[i-1]`
* 边界：`dp[0] = 0`
* 状态转移方程：`dp[i] = Math.max(dp[i-1], prices[i] - min);`

```js
var maxProfit = function(prices) {
    let dp = new Array(prices.length).fill(0)
    dp[0] = 0
    let min = prices[0]
    for (let i = 1; i < prices.length; i++) {
        dp[i] = Math.max(dp[i-1], prices[i] - min)
        if (min > prices[i]) {
            min = prices[i]
        }
    }
    return dp[dp.length-1]
};
```

代码优化之后（看了[官方题解](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/)才领悟到不用 dp 也可直接写出如下）

```js
let maxProfit = function(prices) {
    let max = 0, min = prices[0]
    for(let i = 1; i < prices.length; i++) {
        min = Math.min(prices[i], min)
        max = Math.max(max, prices[i] - min)
    }
    return max
}
```

## 买卖股票的最佳时机（含冷冻期）

```js
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例:
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

* 这道题自己没有想出来，看了很多题解，自己理解一下
* 设 `dp[i]` 为 截止至第`i`天的最大收益
* 对于每一天`i`都有两种状态**持股**和**不持股**，而不持股又分为**当天卖出**和**本来就没有**
  * 持股：设为`dp[i][1]`
  * 不持股
    * 当天卖出了股票所以没有，设为`dp[i][2]`
    * 前一天就没有，今天也没有，设为`dp[i][0]`
* 状态确定好后，下面就是如何建立状态转移方程？
  * 当天持股分为两种情况：**当天买入**和**本来就有**，找出效益最大值
    * 当天买入，前一天一定没有并且前一天没有卖出（`dp[i-1][0]`）,此时效益为`dp[i-1][0] - p[i]`
    * 前一天本来就有，此时的效益为`dp[i-1][1]`
    * 状态转移方程：` dp[i][1] = max(dp[i-1][1], dp[i-1][0] - p[i])`
  * 不持股（当天卖出所以没有）
    * 当天卖出，前一天一定持有，此时的最大效益就是前一天的效益 + 卖出的价格
    * 状态转移方程：`dp[i][2] = dp[i-1][1] + p[i]`
  * 不持股（本来就没有）
    * 说明前一天也没有，最大效益就是前一天两种没有状态的最大值
    * 状态转移方程：` dp[i][0] = max(dp[i-1][0],dp[i-1][2])`
* 截止最后一天的最大效益一定是不持有状态的
* 边界：`dp[0][0] =  0`,`dp[0][2] = 0`,`dp[0][1] = -p[0]` 

```js
var maxProfit = function(prices) {
    if (prices.length === 0) return 0
    const len = prices.length
    let dp = Array.from(new Array(len), () => new Array(3).fill(0))
    dp[0][0] = 0
    dp[0][2] = 0
    dp[0][1] = -prices[0]
    for (let i = 1; i < len; i++) {
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i])
        dp[i][2] = dp[i-1][1] + prices[i]
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2])
    }
    return Math.max(dp[len-1][0], dp[len-1][2])
};
```

## 相同的树

* [leetcode100](https://leetcode-cn.com/problems/same-tree/)

```js
给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
示例 2:

输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
示例 3:

输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```

```js
// 递归
var isSameTree = function(p, q) {
    if(p == null && q == null) return true
    else if((p === null && q !== null) || (p !== null && q === null)) return false
    else if(p.val !== q.val) return false
    else return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
};
```

## 去除重复字母

* [leetcode316](https://leetcode-cn.com/problems/remove-duplicate-letters/)：这道题应用的算法与数据结构是：**贪心+单调栈**，类似的题目还有
* [leetcode402](https://leetcode-cn.com/problems/remove-k-digits)：移掉 k 位数字
* [leetcode42](https://leetcode-cn.com/problems/trapping-rain-water/)：接雨水（hard）

由浅入深，首先来看一下**移掉 k 位数字**这道题

```js
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

注意:
num 的长度小于 10002 且 ≥ k。
num 不会包含任何前导零。

示例 1 :
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。

示例 2 :
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。

示例 3 :
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
```

> 给定一个数字序列，例如 425，如果要求我们只删除一个数字，那么从左到右，我们有 4、2 和 5 三个选择。我们将每一个数字和它的左邻居进行比较。从 2 开始，小于它的左邻居 4。则我们应该去掉数字 4。如果不这么做，则随后无论做什么，都不会得到最小数。
>
> 如果我们保留数字 4，那么所有可能的组合都是以数字 4（即 42，45）开头的。相反，如果去掉 4，留下 2，我们得到的是以 2 开头的组合（即 25），这明显小于任何留下数字 4 的组合。
>
> 这个问题可以用贪心算法来解决。上述规则阐明了我们如何接近最终答案的基本逻辑。一旦我们从序列中删除一个数字，剩下的数字就形成了一个新的问题，我们可以继续使用这个规则。

* 思路：从左向右遍历入栈，若下一个数更小，则上一个数出栈（贪心：局部最优），维护一个单调栈。
* 若 num 是一个增序序列，则不会出栈；是一个降序序列，则会一直出栈。
* 具体解决：
  * 每丢弃一次数字，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。
  * 而当遍历完成，如果 k 仍然大于 0。不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素（因为遍历之后形成的栈已经单调，直接删除末尾的就好）。

  * 要设置 while 循环，因为如果输入为("1234567890", 9)，当遍历到 0 时，比栈顶元素9小，9出栈之后0依旧比栈顶元素8小，所以要设置循环，当 num[i] 一直比栈顶元素小时，则继续出栈
  * 保证数字范围使用 BigInt
  * 若 num.length === k，说明全部删除，直接返回 "0"

```js
function removeKdigits(num, k) {
    let stack = []
    let n = k
    if (num.length === k) return "0"
    for (let i = 0; i < num.length; i++) {
        while (n && num[i] < stack[stack.length - 1]) {
            stack.pop()
            n--
        }
        stack.push(num[i])
    }
    return (BigInt(stack.join("")) + "").slice(0, num.length - k)
}
```

我们再回来看去除重复字母这道题

```js
给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 

示例 1：
输入：s = "bcabc"
输出："abc"

示例 2：
输入：s = "cbacdcbc"
输出："acdb"
```

> 这道题和上题解法类似，不同之处在于去除的元素是基于不重复的规则，所以想到的是用一个结构存储每个字符出现的次数，当字符次数只有一次时不能去除该字符

* 我这里采用 map 存储字符串每个字符出现的次数
* 从左向右遍历字符串，每访问一个字符时和栈顶字符比较字典序，若小于栈顶元素，栈顶元素先出栈（出栈时需判断栈顶字符的次数，为1的时候不能出栈），当前字符再入栈
* 每访问一个字符，当前字符次数减一

```js
var removeDuplicateLetters = function(s) {
    const stack = []
    const map = new Map()
    for (let i in s) {
        map.has(s[i]) ? map.set(s[i], map.get(s[i])+1) : map.set(s[i], 1)
    }
    for (let i in s) {
        if (!stack.includes(s[i])) {
            while (stack.length && s[i] < stack[stack.length-1] && map.get(stack[stack.length-1])) {
                stack.pop()
            }
            stack.push(s[i])
        }
        map.set(s[i], map.get(s[i])-1)
    }
    return stack.join("")
};
```

## 接雨水

* [leetcode42](https://leetcode-cn.com/problems/trapping-rain-water/)

```js
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

* 数据结构：单调栈
* 当后面的柱子高度比前面的低时，是无法接雨水的，当找到一根比前面高的柱子，就可以计算接到的雨水，所以使用单调递减栈
* 当出现高于栈顶的柱子时，说明可以对前面的柱子结算了，计算已经到手的雨水，然后出栈前面更低的柱子
* 推荐看这篇题解中的图示：[单调栈O(n)解决，动图预警🎶🎵](https://leetcode-cn.com/problems/trapping-rain-water/solution/dan-diao-zhan-jie-jue-jie-yu-shui-wen-ti-by-sweeti/)

```js
var trap = function(height) {
    if(!height || height.length == 0){
        return 0;
    }
    let stack = [];
    let res = 0;
    for(let i = 0;i < height.length;i++){
        while(stack.length != 0 && height[stack[stack.length-1]] < height[i]){
            let tmp = stack.pop();
            if(stack.length == 0){
                break;
            }
            // 此时栈顶元素， 出栈元素，当前元素恰好是一个凹型
            res += (Math.min(height[i],height[stack[stack.length-1]]) - height[tmp]) * (i - stack[stack.length-1] - 1);
        }
        stack.push(i);
    }
    return res;
};
```

## 加油站

* [leetcode134](https://leetcode-cn.com/problems/gas-station/)

```js
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

### 暴力解法

* 首先计算 gas 与 cost 的差值，例如 gas  = [1,2,3,4,5]，cost = [3,4,5,1,2]，sub为 [-2, -2, -2, 3, 3]
* 其中 sub[i] > 0  才能作为起始点
* 题目就变为找出能作为起点的索引值 i，从 i 开始轮一圈判断剩余油量大于0直到循环一轮结束
* 时间复杂度 O(n^2)

```js
var canCompleteCircuit = function(gas, cost) {
    let n = gas.length
    for (let i = 0; i < n; i++) {
        if (gas[i] - cost[i] >= 0) {
            let count = gas[i] - cost[i]
            let pos = (i + 1) % n
            let flag = true
            while (pos !== i) {
                count += gas[pos] - cost[pos]
                if (count < 0) {
                    flag = false
                    break
                }
                pos = (pos + 1) % n
            }
            if (!flag) continue
            else return i
        }
    }
    return -1
}
```

### 优化解法

* 首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，则一定可以找到一个解（即索引i），至于为什么可以参考[这篇题解](https://leetcode-cn.com/problems/gas-station/solution/shou-hua-tu-jie-liang-ge-guan-jian-jie-lun-de-jian/)，如果小于零直接返回 -1
* 同样的每个加油站的剩余量sub[i]为gas[i] - cost[i]。
* i从0开始累加sub[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为小于0说明无法到达，这时起始位置从i+1算起，再从0计算curSum。
* 那么为什么一旦[i，j] 区间和为负数，起始位置就可以是j+1呢，j+1后面就不会出现负数？因为如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了。
* 时间复杂度 O(n)

```js
var canCompleteCircuit = function(gas, cost) {
  let total = 0 // 总的剩余油料
  let sub = 0  // 当前站点的剩余油料
  let start = 0 // 起始点
  for(let i = 0; i < gas.length; i++) {
    sub += gas[i] - cost[i]
    if (sub < 0) {
      start = i + 1
      sub = 0
    }
    total += gas[i] - cost[i]
  }
  return total >= 0 ? start: -1
}
```

## 环形链表：双指针

* [leetcode141](https://leetcode-cn.com/problems/linked-list-cycle/)，类似的题目还有
* [leetcode11：](https://leetcode-cn.com/problems/container-with-most-water/)盛最多水的容器
* [leetcode19](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)：删除链表的倒数第n个结点

```js
示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

* 快慢指针法
* 快、慢指针，从头节点出发
* 慢指针每次走一步，快指针每次走两步，不断比较它们指向的节点的值
* 如果节点值相同，说明有环。如果不同，继续循环。

```js
var hasCycle = (head) => {
  let fast = head
  let slow = head
  while (fast) {                        
    if (fast.next == null) return false;
    slow = slow.next                 
    fast = fast.next.next;             
    if (slow == fast) return true 
  }
  return false;                   
}
```

## 环形链表2

* [leetcode142](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
* 相比上一题需要找到环形入口，具体可参考题解[「手画图解+公式推导」链表有环，如何求入环点？](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/141ti-de-kuo-zhan-ru-guo-lian-biao-you-huan-ru-he-/)
* 这种方法自己怎么可能想出来呀。。

```js
var detectCycle = function(head) {
    let slow = head
    let fast = head
    while (fast) {
      if (fast.next == null) return null
      slow = slow.next      
      fast = fast.next.next  
      if (slow == fast) {      
        fast = head          
        while (true) {        
          if (slow == fast) return slow
          slow = slow.next
          fast = fast.next    
        }
      }
    }
    return null    
};
```

**注：以上题解还参考了**

1. [一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～](https://leetcode-cn.com/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5/)

2. [「图解」为什么总加油>=总油耗就一定有解？简单论证两个关键结论 | 附暴力法](https://leetcode-cn.com/problems/gas-station/solution/shou-hua-tu-jie-liang-ge-guan-jian-jie-lun-de-jian/)

