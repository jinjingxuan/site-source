---
title: 手写代码（二）
date: 2020-03-20 09:52:01
categories: 面试
---

* new相关
* Promise相关
* 作用域相关
* this相关
* css相关

* 场景题

## new相关

```js
function Person(name) {
  this.name = name
  return name
}

let p = new Person('Tom')
// 返回什么 Person {name: "Tom"}


function Person(name) {
  this.name = name
  return {}
}

let p = new Person('Tom')
// 返回什么 {}
```

**构造函数不需要显式的返回值。使用new来创建对象(调用构造函数)时，如果return的是非对象(数字、字符串、布尔类型等)会忽而略返回值（忽略return）;如果return的是对象（如果是对象哪么就会丢失原有对象），则返回该对象。**

## Promise相关

```js
function a() {
    console.log('a')
    Promise.resolve().then(() => {
        console.log('e')
    })
}
function b() {
    console.log('b')
}
function c() {
    console.log('c')
}
function d() {
    setTimeout(a, 0)

    var temp = Promise.resolve().then(b) 
    setTimeout(c, 0)
    console.log('d')
}

d() // d b a e c
```

## 作用域相关

```js
var length = 10;
function fn() {
    return this.length+1;
}
var obj = {
    length: 5,
    test1: function() {
        return fn();
    }
};
obj.test2 = fn;
console.log(obj.test1()) // 11
console.log(fn() === obj.test1()) // true



var a = function () { 
    this.b =3
}
var c = new a()
a.prototype.b = 9
var b = 7
a()
console.log(b) // 3
console.log(c.b) // 3



var obj1 = (function() {
  var inner = '1-1';
  return {
    inner: '1-2',
    say: function() {
      console.log(inner); 
      console.log(this.inner);
    }
  }
})();

var obj2 = { inner: '2-1' }
debugger
obj1.say(); // 1-1, 1-2
obj2.say = obj1.say;
obj2.say(); // 1-1, 2-1
```

## this相关

```js
function Person() {  
    this.age = 0;  
    setTimeout(() => {
        this.age++; // 指向 Person
    }, 3000);
}
var p = new Person();


function Person() {  
    this.age = 0
    setTimeout(function() {
        console.log(this) // 指向 window
    }, 3000)
}
var p = new Person();

// 顺便复习以下箭头函数语法
var func1 = x => x;
var func2 = x => {x};
var func3 = x => ({x});
console.log(func1(1)); // 1
console.log(func2(1)); // undefined
console.log(func3(1)); // {x: 1}
```

## css相关

```html
<div class="lightblue">
   <div class="darkblue">
      <p>1. 颜色是？</p> <!-- 深蓝 ，p没设置，继承上面的-->
   </div>
</div>
<div class="darkblue">
   <div class="lightblue">
      <p>2. 颜色是？</p> <!-- 浅蓝 -->
   </div>
</div>
.lightblue { color: lightblue; }
.darkblue { color: darkblue; }

<!------------------------------------------->

<div class="lightblue"> 
   <div class="darkblue"> <!-- 深蓝 -->
      <p>1. 颜色是？</p>
   </div>
</div>
<div class="darkblue">
   <div class="lightblue"> <!-- 深蓝 -->
      <p>2. 颜色是？</p>
   </div>
</div>
.lightblue p { color: lightblue; } <!-- 优先级相同都是10 + 1，写在后面的覆盖写在前面的 -->
.darkblue p { color: darkblue; }
```

## 场景题

> 爬虫在爬取页面前，需要对url列表进行标准化，实现一个处理url列表的函数-对缺少http前缀的url添加前缀，返回的url不能重复
>
> `["nodejs.org", "http://nodejs.org", "http://bytedance.com"] => ["http://nodejs.org", "http://bytedance.com"]`

```js
function formaturl(urllist){
    const res = []
    for (let i in urllist) {
        const reg = /^http:\/\//
        const url = urllist[i]
        const newUrl = reg.test(url) ? url : `http://${url}`
        if (!res.includes(newUrl)) {
            res.push(newUrl)
        }
    }
    return res
}
```

> 以下for 循环存在问题，请改进

```js
//输出结果以及间隔时间，改进 
for (var i = 0; i < 10; i++) {     
  setTimeout(() => {         
    console.log(i)     
  }, 1000)
}

// 1s之后输出10个10
```

setTimeout放入任务队列中，主线程执行完毕之后，等到回调函数执行时，用词法作用域捕获的 i 就只能是 10

**解法1：采用立即执行函数，创建函数作用域；**

```js
for(var i = 0; i < 5; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);
    }, 200);
  })(i);
};
```

**解法2：let  创建块级作用域，可以将块级作用域理解为: 使用let和const声明的变量, 只在当前大括号内生效 ** 

```js
for(let i = 0; i < 5; i++) {
    setTimeout(function() {
      console.log(i);
    }, 200);
};
```

**解法3：暂存i**

```js
for (var i = 0; i < 10; i++) {
    let index = i
    setTimeout(() => {
      console.log(index)
    }, 1000)
}
```

> 下划线转驼峰，驼峰转换下划线

* 正则中需要转义的字符：`* . ? + $ ^ [ ] ( ) { } | \ /`

```js
// 下划线转换驼峰
const toHump = str => {
    return str.replace(/\_(\w)/g, (matchStr, group) => group.toUpperCase())
}

// 驼峰转换下划线
const toLine = str => {
    return str.replace(/([A-Z])/g, (matchStr, group) => `_${group.toLowerCase()}`)
}
```

> 解析url中参数为对象

```js
const getQuery = url => {
    let query = {}
    if (url.includes("?")) {
        const str = url.split("?")[1]
        const params = str.split("&")
        for(let i = 0; i < params.length; i++) {
            const key = params[i].split("=")[0]
            const val = params[i].split("=")[1]
            query[key] = val
        }
    }
    return query
}
```

> 实现如下效果`u.console("hello").settimeout(3000).console("world").settimeout(3000).console("hah").settimeout(0).console("111")`，首先输出hello，3s后输出world,再间隔3s,再输出

```js
// 考点 this 是立即返回的，setTimeout 加入任务队列，时间需要累加计算
class U {
    constructor() {
        this.time = null
        this.totalTime = 0
    }

    console(val) {
        if (this.time === null) {
            console.log(val)
        } else {
            this.totalTime += this.time
            setTimeout(() => {
                console.log(val)
            }, this.totalTime)
        }
        return this
    }

    settimeout(time) {
        this.time = time
        return this
    }
}

let u = new U()
u.console("hello").settimeout(3000).console("world").settimeout(3000).console("hah").settimeout(0).console("111")
```

> 使下面调用代码能正常工作
> `const repeatFunc = repeat(console.log, 4, 3000)`;
> `repeatFunc("helloworld")` //会输出4次 helloworld, 每次间隔3秒

```js
// 需要实现的函数
function repeat (func, times, wait) {
    return function() {
        for (let i = 1; i <= times; i++) {
            setTimeout(() => {
                func(...arguments)
            }, wait * i)
        }
    }
}
```

>  从一个包含学生成绩数组的中找到成绩第k好的所有学生的id,
>  学生信息如下：[{score:89,id:1}, {score:23,id:4}]。

```js
const findK = (arr, k) => {
    const store = Array.from(new Array(101), () => new Array())
    for (let i = 0; i < arr.length; i++) {
        store[arr[i].score].push(arr[i].id)
    }
    let count = 0
    for (let i = 100; i >= 0; i--) {
        if (!store[i].length) continue
        count++
        if (k === count) return store[i]
    }
}

// 注：创建二维数组时，千万不要 new Array(101).fill([]), [] 指向的都是同一个
```

