---
title: 手写代码（二）
date: 2020-03-20 09:52:01
categories: 面试
---

* new相关
* Promise相关
* 作用域相关
* this相关
* css相关
* 原型相关
* 正则相关
* 场景题

## new相关

```js
function Person(name) {
  this.name = name
  return name
}

let p = new Person('Tom')
// 返回什么 Person {name: "Tom"}


function Person(name) {
  this.name = name
  return {}
}

let p = new Person('Tom')
// 返回什么 {}
```

**构造函数不需要显式的返回值。使用new来创建对象(调用构造函数)时，如果return的是非对象(数字、字符串、布尔类型等)会忽而略返回值（忽略return）;如果return的是对象（如果是对象哪么就会丢失原有对象），则返回该对象。**

## Promise相关

```js
function a() {
    console.log('a')
    Promise.resolve().then(() => {
        console.log('e')
    })
}
function b() {
    console.log('b')
}
function c() {
    console.log('c')
}
function d() {
    setTimeout(a, 0)

    var temp = Promise.resolve().then(b) 
    setTimeout(c, 0)
    console.log('d')
}

d() // d b a e c
```

> 设计一个 defer 函数，实现defer(3000).then(res => { // 30ms 后执行 }) ; 
>
> 分析：延时函数

```js
function defer(time) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(1)
        }, time)
    })
}

defer(3000).then(res => {
    console.log(res)
})
// 或者
function defer(time) {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, time, 1)
    })
}

defer(3000).then(res => {
    console.log(res)
})
```

> 交替执行

```js
Promise.resolve().then(() => {
    console.log('a')
}).then(() => {
    console.log('b')
}).then(() => {
    console.log('c')
}).then(() => {
    console.log('d')
}).then(() => {
    console.log('e')
})

Promise.resolve().then(() => {
    console.log(1)
}).then(() => {
    console.log(2)
}).then(() => {
    console.log(3)
}).then(() => {
    console.log(4)
}).then(() => {
    console.log(5)
})

// a 1 b 2 c 3 d 4 e 5
```

```js
Promise.resolve().then(() => {
    console.log(0)
    return Promise.resolve(4)
  	/**
  		相当于这里多了两个微任务，然后交替执行
  		因为返回值可能是 Promise 的嵌套，当前 then 一定递归计算它的最终值，传给下一个 then 的回调
  	*/
}).then(res => {
    console.log(res)
})

Promise.resolve().then(() => {
    console.log(1)
}).then(() => {
    console.log(2)
}).then(() => {
    console.log(3)
}).then(() => {
    console.log(5)
}).then(() => {
    console.log(6)
})

// 0 1 2 3 4 5 6
```

## 作用域相关

```js
var length = 10;
function fn() {
    return this.length+1;
}
var obj = {
    length: 5,
    test1: function() {
        return fn();
    }
};
obj.test2 = fn;
console.log(obj.test1()) // 11
console.log(fn() === obj.test1()) // true



var a = function () { 
    this.b =3
}
var c = new a()
a.prototype.b = 9
var b = 7
a()
console.log(b) // 3
console.log(c.b) // 3



var obj1 = (function() {
  var inner = '1-1';
  return {
    inner: '1-2',
    say: function() {
      console.log(inner); 
      console.log(this.inner);
    }
  }
})();

var obj2 = { inner: '2-1' }
debugger
obj1.say(); // 1-1, 1-2
obj2.say = obj1.say;
obj2.say(); // 1-1, 2-1
```

## this相关

```js
function Person() {  
    this.age = 0;  
    setTimeout(() => {
        this.age++; // 指向 Person
    }, 3000);
}
var p = new Person();


function Person() {  
    this.age = 0
    setTimeout(function() {
        console.log(this) // 指向 window
    }, 3000)
}
var p = new Person();

// 顺便复习以下箭头函数语法
var func1 = x => x;
var func2 = x => {x};
var func3 = x => ({x});
console.log(func1(1)); // 1
console.log(func2(1)); // undefined
console.log(func3(1)); // {x: 1}


const fn = () => {
this.x = 'z';
};

const b = {x: 'y'};
fn.call(b);
console.log(b); // {x: 'y'};
```

## css相关

```html
<div class="lightblue">
   <div class="darkblue">
      <p>1. 颜色是？</p> <!-- 深蓝 ，p没设置，继承上面的-->
   </div>
</div>
<div class="darkblue">
   <div class="lightblue">
      <p>2. 颜色是？</p> <!-- 浅蓝 -->
   </div>
</div>
.lightblue { color: lightblue; }
.darkblue { color: darkblue; }

<!------------------------------------------->

<div class="lightblue"> 
   <div class="darkblue"> <!-- 深蓝 -->
      <p>1. 颜色是？</p>
   </div>
</div>
<div class="darkblue">
   <div class="lightblue"> <!-- 深蓝 -->
      <p>2. 颜色是？</p>
   </div>
</div>
.lightblue p { color: lightblue; } <!-- 优先级相同都是10 + 1，写在后面的覆盖写在前面的 -->
.darkblue p { color: darkblue; }
```

## 原型相关

```js
function Animal() {}
var cat = new Animal();
Animal.prototype = {bark: true};
var dog = new Animal();
console.log(cat.bark); // undefined
console.log(dog.bark); // true


function Animal() {}
var cat = new Animal();
Animal.prototype.bark = true;
var dog = new Animal();
console.log(cat.bark); // true
console.log(dog.bark); // true

function Person(name) {
	this.name = name;
}
Person.prototype.print = function() {
	return this.name;
};

const a = new Person('abc').print.call({});
console.log(a); // undefined
```

```js
// 怎么实现一个多重继承。。可以在一个object对象即可以输出M1的hello也可以输出M2.world
function M1() {
this.hello = 'hello';
}

function M2() {
this.world = 'world';
}

// 首先让 M2 继承 M1
M2.prototype = new M1()

let obj = {}
obj.__proto__ = new M2()

console.log(obj.hello, obj.world) // hello world
```

## 正则相关

* 正则中需要转义的字符：`* . ? + $ ^ [ ] ( ) { } | \ /`

```js
var a = 'hi, my name is {name}, I am {age} years old, my email is {email}.';
var b = {name:'max', age: 12, email: 'max@gmail.com'};


function replace(tpl, data){
    return tpl.replace(/\{(\w+)\}/g, (matchStr, group) => data[group])
}
```

```js
// 下划线转换驼峰
const toHump = str => {
    return str.replace(/\_(\w)/g, (matchStr, group) => group.toUpperCase())
}

// 驼峰转换下划线
const toLine = str => {
    return str.replace(/([A-Z])/g, (matchStr, group) => `_${group.toLowerCase()}`)
}
```

## 场景题

> 爬虫在爬取页面前，需要对url列表进行标准化，实现一个处理url列表的函数-对缺少http前缀的url添加前缀，返回的url不能重复
>
> `["nodejs.org", "http://nodejs.org", "http://bytedance.com"] => ["http://nodejs.org", "http://bytedance.com"]`

```js
function formaturl(urllist){
    const res = []
    for (let i in urllist) {
        const reg = /^http:\/\//
        const url = urllist[i]
        const newUrl = reg.test(url) ? url : `http://${url}`
        if (!res.includes(newUrl)) {
            res.push(newUrl)
        }
    }
    return res
}
```

> 进制转换

```js
function mulBase(num, base){
    let str = ""
    while (num !== 0) {
        str += num % base
        num = Math.floor(num / base)
    }
    return str
}
console.log(mulBase(64,8));
```

> 解析url中参数为对象

```js
const getQuery = url => {
    let query = {}
    if (url.includes("?")) {
        const str = url.split("?")[1]
        const params = str.split("&")
        for(let i = 0; i < params.length; i++) {
            const key = params[i].split("=")[0]
            const val = params[i].split("=")[1]
            query[key] = val
        }
    }
    return query
}
```

> 实现如下效果`u.console("hello").settimeout(3000).console("world").settimeout(3000).console("hah").settimeout(0).console("111")`，首先输出hello，3s后输出world,再间隔3s,再输出

```js
// 考点 this 是立即返回的，setTimeout 加入任务队列，时间需要累加计算
class U {
    constructor() {
        this.time = null
        this.totalTime = 0
    }

    console(val) {
        if (this.time === null) {
            console.log(val)
        } else {
            this.totalTime += this.time
            setTimeout(() => {
                console.log(val)
            }, this.totalTime)
        }
        return this
    }

    settimeout(time) {
        this.time = time
        return this
    }
}

let u = new U()
u.console("hello").settimeout(3000).console("world").settimeout(3000).console("hah").settimeout(0).console("111")
```

> 使下面调用代码能正常工作
> `const repeatFunc = repeat(console.log, 4, 3000)`;
> `repeatFunc("helloworld")` //会输出4次 helloworld, 每次间隔3秒

```js
// 需要实现的函数
function repeat (func, times, wait) {
    return function() {
        for (let i = 1; i <= times; i++) {
            setTimeout(() => {
                func(...arguments)
            }, wait * i)
        }
    }
}
```

>  从一个包含学生成绩数组的中找到成绩第k好的所有学生的id,
>  学生信息如下：[{score:89,id:1}, {score:23,id:4}]。

```js
const findK = (arr, k) => {
    const store = Array.from(new Array(101), () => new Array())
    for (let i = 0; i < arr.length; i++) {
        store[arr[i].score].push(arr[i].id)
    }
    let count = 0
    for (let i = 100; i >= 0; i--) {
        if (!store[i].length) continue
        count++
        if (k === count) return store[i]
    }
}

// 注：创建二维数组时，千万不要 new Array(101).fill([]), [] 指向的都是同一个
```

> 进制转换

```js
function mulBase(num, base){
    let str = ""
    while (num !== 0) {
        str += num % base
        num = Math.floor(num / base)
    }
    return str.split('').reverse().join('')
}
console.log(mulBase(64,8));
```

