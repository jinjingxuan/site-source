---
title: 日常-2020.3.22
date: 2020-03-22 09:52:01
categories: 日常
---

* 算法：求二叉树的宽度
* for循环中的问题详解
* 手写正则判断邮箱
* 手写原生ajax
* display有哪些属性，flex
* position有哪些属性
* 手写一个布局，考虑自适应
* 跨域为什么不行，深入聊

<!--more-->

## 算法：求二叉树宽度

```js
var widthOfBinaryTree = function(root) {
    if (!root) {
        return 0
    }
    const queue = [{ node: root, index: 1 }]
    let max = 1
    while (queue.length) {
        const len = queue.length
        // 这一层的长度为1不需要计算宽度
        if (len > 1) {
            const start = queue[0].index
            const end = queue[len - 1].index
            const width = end - start + 1
            max = Math.max(max, width)
        }
        for (let i = 0; i < len; i++) {
            const temp = queue.shift()
            const node = temp.node
            const index = temp.index
            // 层序遍历过程中，用index来维护节点索引，一个节点索引是index,那他的左孩子索引是index * 2,右孩子索引是index * 2 +1
            node.left && queue.push({ node: node.left, index: index * 2 })
            node.right && queue.push({ node: node.right, index: index * 2 + 1 })
        }
    }
    return max
};
```

## 1.for循环中的问题详解

```html
    <ul>
        <li>第一个</li>
        <li>第二个</li>
        <li>第三个</li>
        <li>第四个</li>
    </ul>

    <script>
        let oli = document.getElementsByTagName("li")
        for(var i=0;i<4;i++){
            oli[i].onclick = function(){
                console.log(i)
            }
        }
        // //相当于
        var i
        i=0
        oli[0].onclick = function(){
                console.log(i)
        }
        i=1
        oli[1].onclick = function(){
                console.log(i)
        }
        i=2
        oli[2].onclick = function(){
                console.log(i)
        }
        i=3
        oli[3].onclick = function(){
                console.log(i)
        }
	    //按照词法作用域查找，会每次都找到全局的i


        //方法一：改为let
        for(let i=0;i<4;i++){
            oli[i].onclick = function(){
                console.log(i)
            }
        }
        //let声明了一个块级作用域，以上相当于
        for(let i=0;i<4;i++){
            let i = //隐藏作用域里的i
            oli[i].onclick = function(){
                console.log(i)
            }
        }
        //这个时候在执行点击事件时，i会在for循环的第一行找到i的值

        //方法二：闭包
        for(var i=0;i<4;i++){
            (function(i){
                oli[i].onclick = function(){
                    console.log(i)
                }
            })(i)
        }
        
        //方法三：暂存数据,和let原理类似
        for(var i=0;i<4;i++){
            oli[i].index = i
            oli[i].onclick = function(){
                console.log(this.index)
            }
        }

        //方法四：事件委托
        var oul = document.getElementsByTagName("ul")[0];
        oul.onclick = function(e){
            var e = e || window.event
            var target = e.target || e.srcElement
            if(target.nodeName.toLowerCase() == 'li'){
                var li=this.querySelectorAll("li");
                var index = Array.prototype.indexOf.call(li,target);
                console.log(index);
　　　　    }
        }
```

```js
for (let i = 0; i < 3; i++) {
    let i = 'foo'
    console.log(i) //foo foo foo
}
```

## 2. 正则判断邮箱

由于名称是由若干个字母、数字、下划线和中划线组成 [a-zA-Z0-9_-]+

```js
let reg = /^[a-zA-z0-9_-]+@[a-zA-z0-9_-]+(\.[a-zA-z0-9_-]+)+$/
reg.test(str)
```

## 3. 原生ajax

```js
        // 原生ajax实现，非常的简单
         function ajax() {
             var xhr = new XMLHttpRequest();
             xhr.open('method', 'url');
             xhr.send();
             xhr.onreadystatechange = function() {
                 if ( xhr.readyState==4 && xhr.status==200) {
                     console.log('success', xhr.responseText);
                 } else {
                     console.log('error', xhr.responseText);
                 }
             }
         }

//readyState
//0：初始化，XMLHttpRequest对象还没有完成初始化
//1：载入，XMLHttpRequest对象开始发送请求
//2：载入完成，XMLHttpRequest对象的请求发送完成
//3：解析，XMLHttpRequest对象开始读取服务器的响应
//4：完成，XMLHttpRequest对象读取服务器响应结束
```

## 4. display有哪些属性

- **display:none;表示此元素将不被显示。**
- **display：block;将元素显示为块元素。（又叫块级元素）**
- **display:inline;将元素显示为内联元素。（又叫行内元素）**

```
内联元素不可以设置高度、宽度
只能设置左右的margin值和左右的padding值，而不能设置上下的margin值和上下的padding值
常见：span、img、input、a、label、button
```

- **display:inline-block;将元素显示为内联块元素。**

```
不换行，但可以设置宽高
```

- **display:inherit;规定应该从父元素继承 display 属性的值。**

## 5.position有哪些属性

* position:static，出现在文档流中，不受top，left影响
* position:relative，相对定位，根据元素原来位置定位，在文档流中
* position:absolute，绝对定位，根据relative的父元素定位，脱离文档流
* positoin:fixed，相对于浏览器窗口固定位置，脱离文档流。
* position:inherit,继承
* position:initial
* position:sticky，

>  position: sticky; 基于用户的滚动位置来定位。

粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。

在目标区域以内，它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。

```html
<style>
        .top,
        .middle,
        .bottom {
            position: relative;
            background: lightblue;
            height: 200px;
        }
        .middle {
            background: yellow;
        }
        .bottom {
            background: pink;
        }
        .fixed {
            width: 100px;
            height: 100px;
            position: fixed;
            background: red;
        }
</style>

	   <div class="top"></div>
        <div class="middle"></div>
        <div class="fixed"></div>
        <div class="bottom"></div>

<!--fixed在bottom的左上角，脱离文档流后被覆盖了-->
```

## 6. 自适应布局

三栏布局，两边固定，中间自适应

```html
<section class="layout flex">
        <style>
            .layout.flex .left-center-right{
                display: flex;
                height: 100px;
            }

            .layout.flex .left{
                width: 300px;
                background-color: red;
            }

            .layout.flex .center{
                flex: 1;
                background-color: yellow;
            }

            .layout.flex .right{
                width: 300px;
                background-color: blue;
            }
        </style>
        <article class="left-center-right">
           <div class="left"></div>
           <div class="center">
               我是中间的自适应元素--flex布局
           </div>
           <div class="right"></div>
        </article>
</section>
```

 `flex` 是 `flex-grow`、`flex-shrink`、`flex-basis`的缩写 

```
.item {flex: 1;}
.item {
    flex-grow: 1;
    flex-shrink: 1;
    flex-basis: 0%;
}
```

## 7. 为什么会有跨域

JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的 