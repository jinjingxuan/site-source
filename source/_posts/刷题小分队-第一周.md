---
title: 刷题小分队第一周
date: 2021-02-01 16:00:54
categories: 刷题
---

## 去除重复字母

* [leetcode316](https://leetcode-cn.com/problems/remove-duplicate-letters/)：这道题应用的算法与数据结构是：**贪心+单调栈**，类似的题目还有
* [leetcode402](https://leetcode-cn.com/problems/remove-k-digits)：移掉 k 位数字

由浅入深，首先来看一下**移掉 k 位数字**这道题

```js
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

注意:
num 的长度小于 10002 且 ≥ k。
num 不会包含任何前导零。

示例 1 :
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。

示例 2 :
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。

示例 3 :
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
```

> 给定一个数字序列，例如 425，如果要求我们只删除一个数字，那么从左到右，我们有 4、2 和 5 三个选择。我们将每一个数字和它的左邻居进行比较。从 2 开始，小于它的左邻居 4。则我们应该去掉数字 4。如果不这么做，则随后无论做什么，都不会得到最小数。
>
> 如果我们保留数字 4，那么所有可能的组合都是以数字 4（即 42，45）开头的。相反，如果去掉 4，留下 2，我们得到的是以 2 开头的组合（即 25），这明显小于任何留下数字 4 的组合。
>
> 这个问题可以用贪心算法来解决。上述规则阐明了我们如何接近最终答案的基本逻辑。一旦我们从序列中删除一个数字，剩下的数字就形成了一个新的问题，我们可以继续使用这个规则。

* 思路：从左向右遍历入栈，若下一个数更小，则上一个数出栈（贪心：局部最优），维护一个单调栈。
* 若 num 是一个增序序列，则不会出栈；是一个降序序列，则会一直出栈。
* 具体解决：
  * 每丢弃一次数字，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。
  * 而当遍历完成，如果 k 仍然大于 0。不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素（因为遍历之后形成的栈已经单调，直接删除末尾的就好）。

  * 要设置 while 循环，因为如果输入为("1234567890", 9)，当遍历到 0 时，比栈顶元素9小，9出栈之后0依旧比栈顶元素8小，所以要设置循环，当 num[i] 一直比栈顶元素小时，则继续出栈
  * 保证数字范围使用 BigInt
  * 若 num.length === k，说明全部删除，直接返回 "0"

```js
function removeKdigits(num, k) {
    let stack = []
    let n = k
    if (num.length === k) return "0"
    for (let i = 0; i < num.length; i++) {
        while (n && num[i] < stack[stack.length - 1]) {
            stack.pop()
            n--
        }
        stack.push(num[i])
    }
    return (BigInt(stack.join("")) + "").slice(0, num.length - k)
}
```

我们再回来看去除重复字母这道题

```js
给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 

示例 1：
输入：s = "bcabc"
输出："abc"

示例 2：
输入：s = "cbacdcbc"
输出："acdb"
```

> 这道题和上题解法类似，不同之处在于去除的元素是基于不重复的规则，所以想到的是用一个结构存储每个字符出现的次数，当字符次数只有一次时不能去除该字符

* 我这里采用 map 存储字符串每个字符出现的次数
* 从左向右遍历字符串，每访问一个字符时和栈顶字符比较字典序，若小于栈顶元素，栈顶元素先出栈（出栈时需判断栈顶字符的次数，为1的时候不能出栈），当前字符再入栈
* 每访问一个字符，当前字符次数减一

```js
var removeDuplicateLetters = function(s) {
    const stack = []
    const map = new Map()
    for (let i in s) {
        map.has(s[i]) ? map.set(s[i], map.get(s[i])+1) : map.set(s[i], 1)
    }
    for (let i in s) {
        if (!stack.includes(s[i])) {
            while (stack.length && s[i] < stack[stack.length-1] && map.get(stack[stack.length-1])) {
                stack.pop()
            }
            stack.push(s[i])
        }
        map.set(s[i], map.get(s[i])-1)
    }
    return stack.join("")
};
```

## 加油站

* [leetcode134](https://leetcode-cn.com/problems/gas-station/)

```js
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

### 暴力解法

* 首先计算 gas 与 cost 的差值，例如 gas  = [1,2,3,4,5]，cost = [3,4,5,1,2]，sub为 [-2, -2, -2, 3, 3]
* 其中 sub[i] > 0  才能作为起始点
* 题目就变为找出能作为起点的索引值 i，从 i 开始轮一圈判断剩余油量大于0直到循环一轮结束
* 时间复杂度 O(n^2)

```js
var canCompleteCircuit = function(gas, cost) {
    let n = gas.length
    for (let i = 0; i < n; i++) {
        if (gas[i] - cost[i] >= 0) {
            let count = gas[i] - cost[i]
            let pos = (i + 1) % n
            let flag = true
            while (pos !== i) {
                count += gas[pos] - cost[pos]
                if (count < 0) {
                    flag = false
                    break
                }
                pos = (pos + 1) % n
            }
            if (!flag) continue
            else return i
        }
    }
    return -1
}
```

### 优化解法

* 首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，则一定可以找到一个解（即索引i），至于为什么可以参考[这篇题解](https://leetcode-cn.com/problems/gas-station/solution/shou-hua-tu-jie-liang-ge-guan-jian-jie-lun-de-jian/)，如果小于零直接返回 -1
* 同样的每个加油站的剩余量sub[i]为gas[i] - cost[i]。
* i从0开始累加sub[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为小于0说明无法到达，这时起始位置从i+1算起，再从0计算curSum。
* 那么为什么一旦[i，j] 区间和为负数，起始位置就可以是j+1呢，j+1后面就不会出现负数？因为如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了。
* 时间复杂度 O(n)

```js
var canCompleteCircuit = function(gas, cost) {
  let total = 0 // 总的剩余油料
  let sub = 0  // 当前站点的剩余油料
  let start = 0 // 起始点
  for(let i = 0; i < gas.length; i++) {
    sub += gas[i] - cost[i]
    if (sub < 0) {
      start = i + 1
      sub = 0
    }
    total += gas[i] - cost[i]
  }
  return total >= 0 ? start: -1
}
```

## 环形链表：双指针

* [leetcode141](https://leetcode-cn.com/problems/linked-list-cycle/)，类似的题目还有
* [leetcode11：](https://leetcode-cn.com/problems/container-with-most-water/)盛最多水的容器
* [leetcode19](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)：删除链表的倒数第n个结点

```js
示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

* 快慢指针法
* 快、慢指针，从头节点出发
* 慢指针每次走一步，快指针每次走两步，不断比较它们指向的节点的值
* 如果节点值相同，说明有环。如果不同，继续循环。

```js
var hasCycle = (head) => {
  let fast = head
  let slow = head
  while (fast) {                        
    if (fast.next == null) return false;
    slow = slow.next                 
    fast = fast.next.next;             
    if (slow == fast) return true 
  }
  return false;                   
}
```

**注：以上题解参考了**

1. [一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～](https://leetcode-cn.com/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5/)

2. [「图解」为什么总加油>=总油耗就一定有解？简单论证两个关键结论 | 附暴力法](https://leetcode-cn.com/problems/gas-station/solution/shou-hua-tu-jie-liang-ge-guan-jian-jie-lun-de-jian/)

