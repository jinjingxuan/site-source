---
title: 数组操作
date: 2020-11-16 16:00:54
categories: 算法
---

* 合并区间
* 只出现一次的数字
* 找到所有数组中消失的数字
* 三数之和
* 数字数组去重排序
* 删除排序数组中的重复项
* 旋转矩阵

## 合并区间

题目来源：[leetcode56](https://leetcode-cn.com/problems/merge-intervals/)

```js
示例 1:

输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2:
输入: intervals = [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

* 思路

```js
// 1. 先按照 intervals[i][0] 从小到大排序
// 2. intervals[i][1] >= intervals[i+1][1] 直接取 intervals[i][1] : [1,4] [2,3] 直接取 [1,4]
// 3. intervals[i][1] >= intervals[i+1][0] 时 intervals[i][1] = intervals[i+1][1] ：[1,4] [3,5] 取 [1,5]  
// 4. 设置一个 flag，如果此轮合并过，继续合并下一轮  
```

* 个人解法

```js
var merge = function(intervals) {
    let flag = true 
    intervals.sort((a,b) => a[0] - b[0])
    while (flag) {
        flag = false
        for (let i = 0;i < intervals.length - 1;i++) {
            if (intervals[i][1] >= intervals[i+1][1]) {
                intervals.splice(i+1,1)
                flag = true
            } else if (intervals[i][1] >= intervals[i+1][0]) {
                intervals[i][1] = intervals[i+1][1]
                intervals.splice(i+1,1)
                flag = true
            }     
        }
    }
    return intervals
};
```

## 只出现一次的数字

* [leetcode136](https://leetcode-cn.com/problems/single-number/)

```js
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4
```

* 任何数和 0 做异或运算，结果仍然是原来的数，
* 任何数和其自身做异或运算，结果是 0
* 异或运算满足交换律和结合律

```js
var singleNumber = function(nums) {
    return nums.reduce((pre, item) => pre ^ item, 0)
};
```

## 找到所有数组中消失的数字

* [leetcode448](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

```js
给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

示例:

输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
```

* 值表示索引

```js
var findDisappearedNumbers = function(nums) {
    let arr = [], res = []
    for (let i = 0; i < nums.length; i++) {
        arr[nums[i]-1] = 1
    }
    for (let i = 0; i < nums.length; i++) {
        if (arr[i] !== 1) {
            res.push(i+1)
        } 
    }
    return res
};
```

## 三数之和

* [leetcode15](https://leetcode-cn.com/problems/3sum/)

```js
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

* 双指针讲思路
* [题解](https://leetcode-cn.com/problems/3sum/solution/man-hua-jue-bu-wu-ren-zi-di-xiang-kuai-su-kan-dong/)

```js
var threeSum = function(nums) {
    nums.sort((a, b) => a - b) // 排序
    let ans = []
    for (let flag = 0; flag < nums.length - 2; flag++) {
        if (nums[flag] > 0) break // 基准值大于0时相加不可能等于0
        let i = flag + 1
        let j = nums.length - 1
        while (i < j) {
            if (nums[flag] + nums[i] + nums[j] > 0) j--
            else if (nums[flag] + nums[i] + nums[j] < 0) i++
            // 相加等于0时，需要去重
            else {
                if (ans.length === 0) {
                    ans.push([nums[flag], nums[i], nums[j]])
                } else {
                    let boolean = true
                    // ans中向前遍历，判断有没有一样的，有一样的就不 push 了
                    for (let k = ans.length-1; k >= 0 && ans[k][0] === nums[flag]; k--) {
                        let tmp = ans[k]
                        if (tmp[0] === nums[flag] && tmp[1] === nums[i] && tmp[2] === nums[j]) {
                            boolean = false
                        } 
                    }
                    if (boolean) {
                         ans.push([nums[flag], nums[i], nums[j]])
                    }
                }
                i++
                j--
            }
        }
    }
    return ans
};
```

## 数字数组去重排序

* 用下标表示数字，空间复杂度较高，一般不建议使用

```js
const arr = [5, 1, 1, 3, 2, 0]

const foo = (arr) => {
  const res = []
  const ans = []
  for (let i in arr) {
      res[arr[i]] = 1
  }
  for (let i in res) {
      ans.push(i)
  }
  return ans
}
```

## 删除排序数组中的重复项

> 示例 1:
>
> 给定数组 nums = [1,1,2], 
>
> 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 (注意只需修改，不需删除)
>
> 你不需要考虑数组中超出新长度后面的元素。
>
> 示例 2:
>
> 给定 nums = [0,0,1,1,1,2,2,3,3,4],
>
> 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
>
> 你不需要考虑数组中超出新长度后面的元素。

* 遍历一次，不重复的放在数组前几位，时间复杂度O（n)

```js
var removeDuplicates = function(nums) {
    let len = 1
    for(let i = 1; i < nums.length; i++){
        if(nums[i]!==nums[i-1]) nums[len++] = nums[i]
    }
    return len
};
```

> 给定 nums = [3,2,2,3], val = 3,
>
> 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
>
> 你不需要考虑数组中超出新长度后面的元素。
>
>
> 给定 nums = [0,1,2,2,3,0,4,2], val = 2,
>
> 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
>
> 注意这五个元素可为任意顺序。
>
> 你不需要考虑数组中超出新长度后面的元素。

```js
var removeElement = function(nums, val) {
    let len = 0
    for(let i = 0; i < nums.length; i++){
        if(nums[i] !== val) nums[len++] = nums[i]
    }
    return len
};
```

## 旋转矩阵

* [leetcode48](https://leetcode-cn.com/problems/rotate-image/)

> 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。
>
> 示例 1:
>
> 给定 matrix = 
> [
>   [1,2,3],
>   [4,5,6],
>   [7,8,9]
> ],
>
> 原地旋转输入矩阵，使其变为:
> [
>   [7,4,1],
>   [8,5,2],
>   [9,6,3]
> ]

```js
var rotate = function(matrix) { 
    const len = matrix.length;
    for(let i = 0; i < len; i++){
        for(let j = 0; j < len; j++){
            let curr = matrix[i].pop()
            matrix[len - j - 1].unshift(curr)
        }
    }
};
```

* 具体过程如下：

```js
[ [ 1, 2 ], [ 4, 5, 6 ], [ 3, 7, 8, 9 ] ]

[ [ 1 ], [ 2, 4, 5, 6 ], [ 3, 7, 8, 9 ] ]

[ [ 1 ], [ 2, 4, 5, 6 ], [ 3, 7, 8, 9 ] ]

[ [ 1 ], [ 2, 4, 5 ], [ 6, 3, 7, 8, 9 ] ]

[ [ 1 ], [ 5, 2, 4 ], [ 6, 3, 7, 8, 9 ] ]

[ [ 4, 1 ], [ 5, 2 ], [ 6, 3, 7, 8, 9 ] ]

[ [ 4, 1 ], [ 5, 2 ], [ 9, 6, 3, 7, 8 ] ]

[ [ 4, 1 ], [ 8, 5, 2 ], [ 9, 6, 3, 7 ] ]

[ [ 7, 4, 1 ], [ 8, 5, 2 ], [ 9, 6, 3 ] ]
```

