---
title: 日常-2020.3.10
date: 2020-03-10 09:52:01
categories: 日常
---

* 事件冒泡与事件捕获
* 重绘与回流
* requestAnimationFrame 和 setTimeout 的区别 
* 事件委托机制
* 前端路由的实现方法
* for in和for of的区别

<!--more-->

## 事件冒泡与事件捕获

* **事件冒泡**

> 当给父子元素的同一事件绑定方法的时候，触发子元素身上的事件，执行完毕之后，也会触发父级元素相同的事件，这种机制叫事件冒泡 

* 事件捕获

> 给父子元素用绑定同一事件时，当触发子元素身上的事件时，先触发父元素，然后在传递给子元素，这种传播机制叫事件捕获；

```html
	   <div id="box1">
            <div id="box2">
                <div id="box3"></div>
            </div>
        </div>

        <script>
            function sayBox3() {
                console.log('你点了最里面的box');
            }
            function sayBox2() {
                console.log('你点了最中间的box');
            }
            function sayBox1() {
                console.log('你点了最外面的box');
            }
            // 事件监听，第三个参数是布尔值，默认false，false是事件冒泡，true是事件捕获
            document.getElementById('box3').addEventListener('click', sayBox3, false);
            document.getElementById('box2').addEventListener('click', sayBox2, false);
            document.getElementById('box1').addEventListener('click', sayBox1, false);

        </script>
```

 ## 重绘与回流

在页面加载时，浏览器把获取到的HTML代码解析成1个DOM树。 DOM Tree 和样式结构体组合后构建render tree，render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点，因为这些节点不会用于呈现，而且不会影响呈现的。

![1](https://segmentfault.com/img/bVbaC2e?w=624&h=289)

### 什么是回流

当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

### 什么是重绘

当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。

### 区别：

* 回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流
* 当页面布局和几何属性改变时就需要回流。比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变

### 浏览器的优化机制 

 由于每次回流都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化回流过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。 

 ### 如何减少回流，重绘

*  直接避免：采用transform,opacity可以直接跳过主线程，用compositer线程完成
*  合并多次对DOM和样式的修改
*  将复杂的元素绝对定位，脱离文档流，否则回流的代价很高。

## requestAnimationFrame 和 setTimeout 的区别 

### （1）seTimeout实现动画：

利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象

　　**原因一**、setTimeout的执行时间并不是确定的。在Javascript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。

　　**原因二**、刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。

　　上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。

**setTimeout的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。**

### （2）**requestAnimationFrame实现动画：** 

​	requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。

　　如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。

```js
var num = 0;
animation = null;

function fn(){
	console.log( num++ );
	animation = requestAnimationFrame(fn);//异步
}
fn();
	
document.onclick = function(){
	cancelAnimation( animation );
}
```

## 事件委托机制

JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 

### 为什么要用事件委托

一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？

在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；

每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了，比如上面的100个li，就要占用100个内存空间，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。

如何实现呢？

```html
<ul id='ul'>
    <li></li>
    <li></li>
    <li></li>
</ul>
<script>
window.onload = function(){
    var oul = document.getElementById("ul");
    oul.onclick = function(){
        alert(123);
    }
}
</script>
<!--怎么知道点击的是那个li呢，通过事件对象，Event对象提供了一个属性叫target，可以返回事件的目标节点，我们称为事件源，-->
<script>
window.onload = function(){
　　var oul = document.getElementById("ul");
　　oul.onclick = function(e){
　　　　var e = e || window.event;
　　　　var target = e.target || e.srcElement;  //IE浏览器用event.srcElement
　　　　if(target.nodeName.toLowerCase() == 'li'){
　 　　　　　　	alert(123);
　　　　}
　　}
}
</script>
```

## 前端路由的实现方法

### **什么是前端路由？**

路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。

在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。

### **如何实现前端路由？**

要实现前端路由，需要解决两个核心问题：

1. 如何改变 URL 却不引起页面刷新？
2. 如何检测 URL 变化了？

下面分别使用 hash 和 history 两种实现方式回答上面的两个核心问题。

### **hash 实现:**点击链接则改变hash，监听hash是否改变，改变就重新渲染UI

1. hash 是 URL 中 hash (`#`) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新
2. 通过 [hashchange](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event) 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过`标签改变 URL、通过wind`ow.location改变URL，这几种情况改变 URL 都会触发 hashchange 事件

```html
		<ul>
          <!-- 定义路由 -->
          <li><a href="#/home">home</a></li>
          <li><a href="#/about">about</a></li>
      
          <!-- 渲染路由对应的 UI -->
          <div id="routeView"></div>
        </ul>
        
        <script>
            // 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件
            window.addEventListener('DOMContentLoaded', onLoad)
            // 监听路由变化
            window.addEventListener('hashchange', onHashChange)

            // 路由视图
            var routerView = null

            function onLoad () {
                routerView = document.querySelector('#routeView')
                onHashChange()
            }

            // 路由变化时，根据路由渲染对应 UI
            function onHashChange () {
                switch (location.hash) {
                    case '#/home':
                    routerView.innerHTML = 'Home'
                    return
                    case '#/about':
                    routerView.innerHTML = 'About'
                    return
                    default:
                    return
                }
            }
        </script>
```

### history 实现:点击链接后,采用pushState改变url，根据url的变化渲染ui

1. history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新.但是会分别添加和修改历史记录。
2. history 提供类似 hashchange 事件的 [popstate](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event) 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过`pushState/replaceState`或标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState，eplaceState的调用和标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。

 ```html
		<ul>
          <!-- 定义路由 -->
          <li><a href="/home">home</a></li>
          <li><a href="/about">about</a></li>
      
          <!-- 渲染路由对应的 UI -->
          <div id="routeView"></div>
        </ul>

<script>
            // 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件
            window.addEventListener('DOMContentLoaded', onLoad)
            // 监听路由变化
            window.addEventListener('popstate', onPopState)

            // 路由视图
            var routerView = null

            function onLoad () {
            routerView = document.querySelector('#routeView')
            onPopState()

            // 拦截 <a> 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。
            var linkList = document.querySelectorAll('a[href]')
            linkList.forEach(el => el.addEventListener('click', function (e) {
                e.preventDefault()
                history.pushState(null, '', el.getAttribute('href'))
                onPopState()
            }))
            }

            // 路由变化时，根据路由渲染对应 UI
            function onPopState () {
            switch (location.pathname) {
                case '/home':
                routerView.innerHTML = 'Home'
                return
                case '/about':
                routerView.innerHTML = 'About'
                return
                default:
                return
  }
}
</script>
 ```

## for in和for of的区别

 最直接的区别是：

* for in遍历的是数组的索引（即键名），
* for of遍历的是数组元素值。

除此之外，对于for in的缺点

1. 索引是字符串型的数字，因而不能直接进行几何运算
2. 遍历顺序可能不是实际的内部顺序
3. for in会遍历数组所有的可枚举属性，包括原型。例如的原型方法method和name属性

对于for of的缺点：

1. for of不支持普通对象

```js
Array.prototype.method=function(){}
var myArray=[1,2,4];
myArray.name="数组";
 
for (var index in myArray)
    console.log(myArray[index]);    //0,1,2,method,name
 
for (var value of myArray) 
    console.log(value);    //1,2,4

var obj = {
    a:1,
    b:2
}
for(var i in obj){
    console.log(obj[i])   //1,2
}
for(var j of obj){
    console.log(j)        //报错obj[Symbol.iterator] is not a function
}
```
