---
title: 回溯算法
date: 2020-11-30 16:00:54
categories: 算法
---

* 全排列
* 括号生成
* 电话号码的数字组合
* 子集
* 二维数组全排列
* 组合总和
* 组合总和II
* 单词搜索
* 三角形的最小路径和

## 回溯算法

**解决一个回溯问题，实际上就是一个决策树的遍历过程**。基本原理就是**递归**，用白话解释就是：**从一条路往前走，能进则进，不能进则退回来，换一条路再试。**只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

代码方面，回溯算法的框架：

```js
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**

## 全排列

* [Leetcode46](https://leetcode-cn.com/problems/permutations/)

```js
 给定一个 没有重复 数字的序列，返回其所有可能的全排列。
 
 示例:
 输入: [1,2,3]
 输出:
 [
 [1,2,3],
 [1,3,2],
 [2,1,3],
 [2,3,1],
 [3,1,2],
 [3,2,1]
]
```

我们要在这个包含解的空间树上，用 递归的方式搜索出所有的解。

```js
const permute = (nums) => {
  const res = [];

  function backtrack(path) {
    if (path.length == nums.length) {
      // slice的原因是防止push到res中的结果是引用类型，后面path改变时会影响res
      res.push(path.slice()); 
      return;
    }
    for (const num of nums) {
      if (path.includes(num)) continue;
      path.push(num);  // 比如目前 path 是 [1]，push(2), 变成 [1, 2]
      backtrack(path); // 递归到头了：[1,2,3] 就 return 
      path.pop();      // [1,2] pop 变为 [1]， 继续下一轮 for 循环, push(3)
    }
  }

  backtrack([]);
  return res;
};
```

## 括号生成

* [leetcode22](https://leetcode-cn.com/problems/generate-parentheses/)
* [题解](https://leetcode-cn.com/problems/generate-parentheses/solution/shou-hua-tu-jie-gua-hao-sheng-cheng-hui-su-suan-fa/)

```js
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

示例：
输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
```

```js
var generateParenthesis = function (n) {
  const res = [];

  const backtrack = (lRemain, rRemain, str) => { // 左右括号所剩的数量，str是当前构建的字符串
    if (str.length == 2 * n) { // 字符串构建完成
      res.push(str);           // 加入解集
      return
    }
    // 下面两种情况都会判断执行
    if (lRemain > 0) {         // 只要左括号有剩，就可以选它，然后继续做选择（递归）
      backtrack(lRemain - 1, rRemain, str + "(");
    }
    if (lRemain < rRemain) {   // 右括号比左括号剩的多，才能选右括号
      backtrack(lRemain, rRemain - 1, str + ")"); // 然后继续做选择（递归）
    }
  };

  backtrack(n, n, ""); // 递归的入口，剩余数量都是n，初始字符串是空串
  return res;
};
```

## 电话号码的数字组合

* [leetcode17](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

* [题解](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/shou-hua-tu-jie-liang-chong-jie-fa-dfshui-su-bfsya/)

```js
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

示例:
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

```js
var letterCombinations = function(digits) {
    if (digits.length == 0) return [];
    const map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' };

    const res = []
    const backtrack = (curStr, i) => {     
      if (i > digits.length - 1) {    
        res.push(curStr);             
        return;     // 一定要加，结束当前分支                  
      }
      const letters = map[digits[i]]; 
      for (const l of letters) {      
        backtrack(curStr + l, i + 1);     
      }
    };
    backtrack('', 0);
    return res;
};
```

## 子集

* [Leetcode78](https://leetcode-cn.com/problems/subsets/)
* [题解](https://leetcode-cn.com/problems/subsets/solution/shou-hua-tu-jie-zi-ji-hui-su-fa-xiang-jie-wei-yun-/)

```js
给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

```js
var subsets = function(nums) {
    const res = []
    const backtrack = (index, list) => {
        if (index == nums.length) { // 指针越界
          res.push(list.slice());   // 加入解集
          return;                   // 结束当前的递归
        }
        list.push(nums[index]); // 选择这个数
        backtrack(index + 1, list);   // 基于该选择，继续往下递归
        list.pop();             // 上面的递归结束，撤销该选择
        backtrack(index + 1, list);   // 不选这个数，继续往下递归
      };
    
      backtrack(0, []);
      return res;
};
```

## 二维数组全排列

> var arr = [[‘A’,’B’],[‘a’,’b’],[1,2]]` 
>
> 求二维数组的全排列组合 结果：[Aa1,Aa2,Ab1,Ab2,Ba1,Ba2,Bb1,Bb2]

```js
const fullArray = (arr) => {
    const res = []
    const traceBack = (path, n) => {
        if (path.length === arr.length) {
            res.push(path.slice())
            return
        }
        for (const item of arr[n]) {
            traceBack(path + item, n+1)
        }
    }
    traceBack('', 0)
    return res
}
```

## 组合总和

* [leetcode39](https://leetcode-cn.com/problems/combination-sum/)
* [题解](https://leetcode-cn.com/problems/combination-sum/solution/shou-hua-tu-jie-zu-he-zong-he-combination-sum-by-x/)

> 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的数字可以无限制重复被选取。
>
> 说明：
>
> 所有数字（包括 target）都是正整数。
> 解集不能包含重复的组合。 
>
> 示例 1：
>
> 输入：candidates = [2,3,6,7], target = 7,
> 所求解集为：
> [
>   [7],
>   [2,2,3]
> ]
>
> 示例 2：
>
> 输入：candidates = [2,3,5], target = 8,
> 所求解集为：
> [
>   [2,2,2,2],
>   [2,3,3],
>   [3,5]
> ]

```js
var combinationSum = function(candidates, target) {
    const res = []
    // start 用于剪枝
    const traceback = (start, path, sum) => {
        if (sum > target) return
        if (sum === target) {
            res.push(path.slice())
            return
        }
        for (let i = start; i < candidates.length; i++) {
            path.push(candidates[i])
            traceback(i, path, sum + candidates[i])
            path.pop()
        }
    }
    traceback(0, [], 0)
    return res
};
```

## 组合总和II

* [leetcode40](https://leetcode-cn.com/problems/combination-sum-ii/)
* [题解](https://leetcode-cn.com/problems/combination-sum-ii/solution/man-tan-wo-li-jie-de-hui-su-chang-wen-shou-hua-tu-/)

> 接上题，每个数字只可使用一次
>
> **示例 1:**
>
> 输入: candidates = [10,1,2,7,6,1,5], target = 8,
> 所求解集为:
> [
>   [1, 7],
>   [1, 2, 5],
>   [2, 6],
>   [1, 1, 6]
> ]
>
> **示例 2:**
>
> 输入: candidates = [2,5,2,1,2], target = 5,
> 所求解集为:
> [
>   [1,2,2],
>   [5]
> ]

```js
var combinationSum2 = function(candidates, target) {
    candidates.sort((a,b) => a - b ) // 升序排序
    const res = []
    const traceback = (start, path, sum) => {
        if (sum > target) return
        if (sum === target) {
            res.push(path.slice())
            return
        }
        for (let i = start; i < candidates.length; i++) {
            if (i - 1 >= start && candidates[i - 1] == candidates[i]) { // 当前选项和左邻选项一样，跳过
                continue
            }
            path.push(candidates[i])
            traceback(i + 1, path, sum + candidates[i])
            path.pop()
        }
    }
    traceback(0, [], 0)
    return res
};
```

## 单词搜索

* [leetcode79](https://leetcode-cn.com/problems/word-search/)
* [题解](https://leetcode-cn.com/problems/word-search/solution/shou-hua-tu-jie-79-dan-ci-sou-suo-dfs-si-lu-de-cha/)

> 给定一个二维网格和一个单词，找出该单词是否存在于网格中。
>
> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
>
> 示例:
>
> board =
> [
>   ['A','B','C','E'],
>   ['S','F','C','S'],
>   ['A','D','E','E']
> ]
>
> 给定 word = "ABCCED", 返回 true
> 给定 word = "SEE", 返回 true
> 给定 word = "ABCB", 返回 false

```js
var exist = function(board, word) {
    const m = board.length
    const n = board[0].length
    const used = Array.from(new Array(m),()=>(new Array(n).fill(0)))
        
    const traceback = (row, col, i) => {
      if (i == word.length) {
        return true
      }
      // 越界
      if (row < 0 || row >= m || col < 0 || col >= n) {
        return false
      }
      // 已访问或不匹配
      if (used[row][col] || board[row][col] != word[i]) {
        return false
      }
      // 匹配记录一下当前点被访问了
      used[row][col] = true
  
      const canFindRest = traceback(row + 1, col, i + 1) || traceback(row - 1, col, i + 1) 					|| traceback(row, col + 1, i + 1) || traceback(row, col - 1, i + 1)
      
      // 能找到路径
      if (canFindRest) {
        return true
      }

      // 找不到路径
      used[row][col] = false
      return false
    }

    // 找入口
    for (let i = 0; i < m; i++) {
      for (let j = 0; j < n; j++) {
        if (board[i][j] == word[0] && traceback(i, j, 0)) {
          return true; 
        }
      }
    }
    return false
};
```

## 三角形的最小路径和

* [leetcode120](https://leetcode-cn.com/problems/triangle/)

```js
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

```js
var minimumTotal = function(triangle) {
    let res = 999999
    // path: 路径和 | n: 记录第几层 | index: 当前层选中的index
    const backtrack = (path, n, index) => {
        if (n > triangle.length - 1) {
            res = Math.min(res, path)
            return
        }
        backtrack(path + triangle[n][index], n + 1, index)
        backtrack(path + triangle[n][index], n + 1, index + 1)
    }
    backtrack(0, 0, 0)
    return res
};
```

**回溯思路可行，但是给的测试用例会超时，更优的解法应该是[dp](https://jinjingxuan.github.io/2020/11/16/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/)**

