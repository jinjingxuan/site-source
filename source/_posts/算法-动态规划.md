---
title: 动态规划
date: 2020-11-16 16:01:54
categories: 算法
---

* 爬楼梯
* 最大子序列和
* 最长回文子串
* 不同路径
* 最小路径和
* 正则表达式匹配
* 分割等和子集

> 动态规划的三个概念：最优子结构，边界，状态转移方程

## 爬楼梯

```js
有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。
```

* 思考：如果只差最后一步就走到第 10 级，此时分为两种：从第 9 级到 10 级，从第 8 级到 10 级
* 0 到 9 级的走法有 x，0 到 8 级的走法有 y 种，那么 0 到 10 级的走法一共有 x+y
* F(10) = F(9) + F(8)，F(8) = F(8) + F(7)
*  F(9) 和 F(8) 是 F(10) 的最优子结构
* 边界是 F(1) 和 F(2)
* 状态转移方程是 F(n) = F(n-1) + F(n-2)

```js
function getClimbingWays(n) {
    if (n < 1) return 0
    if (n === 1) return 1
    if (n === 2) return 2
    let a = 1, b = 2, temp = 0
    for (let i = 3; i <= n; i++) {
        temp = a + b
        a = b
        b = temp
    }
    return temp
}
```

## 最大子序列和

```js
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

* 分析：答案肯定是在以下组合中：
* 第一个子组合是以第一个数字结尾的连续序列，也就是[-2]，最大值-2
* 第二个子组合是以第二个数字结尾的连续序列，也就是[-2,1], [1]，最大值1
* 第三个子组合是以第三个数字结尾的连续序列，也就是[-2,1,-3], [1,-3], [-3]，最大值-2
* 第四个子组合是以第四个数字结尾的连续序列，也就是[-2,1,-3,4],[1.-3,4],[-3,4],[4]，最大值4
* 第n个子组合......

****

* 最优子结构：组合n只是在组合n-1的基础上每一个数组后面添加1个数字num，然后增加一个只有第n个数字的数组[num]，只需要比较前一个组合的最大值+num和num
* 边界：dp[0] = nums[0] = -2
* 状态转移方程：dp[i] = max(dp[i-1]+nums[i], nums[i])

```js
// 组合3只是在组合2的基础上每一个数组后面添加第3个数字，也就是3，然后增加一个只有第三个数字的数组[3]
// 只需要比较前一个组合的最大值+num和num
// 计算出九个组合的最大值，再取最大的即可

var maxSubArray = function(nums) {
    let dp = []
    let result = nums[0]
    dp[0] = nums[0]
    for(let i = 1; i < nums.length; i++){
        dp[i] = Math.max(dp[i-1]+nums[i],nums[i])
        if(dp[i] > result) result = dp[i]
    }
    return result
};
```

## 最长回文子串

* [leetcode5](https://leetcode-cn.com/problems/longest-palindromic-substring)

```js
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

示例 2：
输入: "cbbd"
输出: "bb"
```

* 分析：i 到 j 是回文子串那么 i+1 到 j-1 也是回文子串
* i 到 j 的最优子结构就是 i+1 到 j-1
* 边界就是单个字符或者 aa 这种
* 状态转移方程是：`dp[i][j] = dp[i+1][j-1] && s[i] == s[j]`

```js
var longestPalindrome = function(s) {
    if (!s) return ""
    let res = [], dp = []

    // 从后向前遍历，因为 dp[i] 依赖于 dp [i+1]
    for (let i = s.length - 1; i >= 0; i--) {
        dp[i] = []
        for (let j = i; j < s.length; j++) {
            // 边界
            if (i === j || (j - i === 1 && s[i] === s[j])) {
                dp[i][j] = true
            }
            // 状态转移
            else if (s[i] === s[j] && dp[i + 1][j - 1]) {
                dp[i][j] = true
            }
            if (dp[i][j] && j - i + 1 > res.length) {
                res = s.slice(i, j + 1);
            }
        }
    }
    return res
};
```

## 不同路径

* [leetcode62](https://leetcode-cn.com/problems/unique-paths/)

```js
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

示例 1:
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

示例 2:
输入: m = 7, n = 3
输出: 28
```

* 分析：到达终点总是向右或向下，故到达终点的走法=到达其上面点的走法 + 到达其左面点的走法
* 状态转移：`map[m][n] = map[m-1][n] + map[m][n-1]`
* 边界：`map[0][j] = 1,map[i][0] = 1`

```js
	// 初始化二维数组
    let map = Array.from(new Array(m),()=>(new Array(n).fill(0)))
    for (let j = 0; j < n; j++) {
        map[0][j] = 1
    }
    for (let i = 0; i < m; i++) {
        map[i][0] = 1
    }
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            map[i][j] = map[i-1][j] + map[i][j-1]
        }
    }
    return map[m-1][n-1]
```

#### Array.from

**将一个类数组对象或者可遍历对象转换成一个真正的数组。**

* 该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。

* 该类数组对象的属性名必须为数值型或字符串型的数字

* 该类数组对象的属性名可以加引号，也可以不加引号
* `Array.from`可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。

## 最小路径和

* [leetcode64](https://leetcode-cn.com/problems/minimum-path-sum/)

```js
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例 1：
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。

示例 2：
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

* 思路：到`grid[i][j]`的最小值，肯定等于到`grid[i-1][j]`的最小值和到`grid[i][j-1]`的最小值中较小的加上当前`grid[i][j]`的值
* 最优子结构：`dp[i-1][j], dp[i][j-1]`中小的那个
* 边界：`dp[0][0] = grid[0][0]`
* 状态转移方程：`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] `；

```js
var minPathSum = function(grid) {
    let m = grid.length
    let n = grid[0].length
    let dp = Array.from(new Array(m),()=>(new Array(n).fill(0)))
    dp[0][0] = grid[0][0]
    for (let i = 1; i < m; i++) {
        dp[i][0] = dp[i-1][0] + grid[i][0];
    }
    for (let j = 1; j < n; j++) {
        dp[0][j] = dp[0][j-1] + grid[0][j];
    }
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = Math.min(dp[i][j-1], dp[i-1][j]) + grid[i][j];
        }
    }
    return dp[m-1][n-1]
};
```

## 正则表达式匹配

* [leetcode10](https://leetcode-cn.com/problems/regular-expression-matching/)

* [题解](https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/)

## 分割等和子集

* [leetcode416](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

> 这个问题可以转化为求数组的一个子集，使得这个子集中的元素的和尽可能接近sum/2，其中sum为数组中所有元素的和。这样转换之后这个问题就很类似0-1背包问题了：在n件物品中找到m件物品，他们的可以装入背包中，且总价值最大不过这里不考虑价值，就考虑使得这些元素的和尽量接近sum/2。

* [背包问题分析](https://juejin.cn/post/6844903607855251463)

```js
输入: n物品重W[1:n], 价值V[1:n], 背包容量C
输出: 装包使得价值最大 (物品重量为整数).

dp[i,k] = 由[1:i]组合出重量<=k的最大价值

如果第i件物品没有包括在其中，则dp[i,k] = dp[i-1,k]
如果第i件物品包括在其中，则dp[i,k] = dp[i-1,k-W[i]] + V[i]

转移方程：dp[i,k] = max{ dp[i-1,k], dp[i-1,k-W[i]] + V[i] }
```

```js
var canPartition = function(nums) {
    let len = nums.length
    let sum = 0
    for (let i = 0; i < len; i++) {
        sum += nums[i]
    }
    let midSum = sum >> 1
    let dp = Array.from(new Array(len + 1),()=>(new Array(midSum + 1).fill(0)))
    for (let i = 1; i <= len; i++) {
        for (let j = 1; j <= midSum; j++) {
            if (j >= nums[i - 1]) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i-1]] + nums[i - 1])
            }
            else {
                dp[i][j] = dp[i - 1][j]
            }
        }
    }
    return dp[len][midSum] === sum / 2
};
```
