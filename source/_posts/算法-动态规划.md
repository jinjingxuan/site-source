---
title: 动态规划
date: 2020-11-16 16:01:54
categories: 算法
---

* 爬楼梯
* 最大子序列和
* 最长回文子串
* 不同路径
* 最小路径和
* 正则表达式匹配
* 分割等和子集
* 三角形的最小路径和
* 买卖股票的最佳时机
* 买卖股票的最佳时机（含冷冻期）

> 动态规划的三个概念：最优子结构，边界，状态转移方程

## 动态规划与贪心的区别

> 贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。 贪心是求局部最优，以得到全局最优（不一定是正确的，需要证明）
>
> 比如某国的钱币分为1元3元4元，如果要拿6元钱怎么拿？贪心的话先拿4再拿两个1，一共3张钱，而实际最优其实是两张3元（类似于背包问题，需要考虑物品个数）
>
> 动态规划算法中，全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解 

## 爬楼梯

```js
有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。
```

* 思考：如果只差最后一步就走到第 10 级，此时分为两种：从第 9 级到 10 级，从第 8 级到 10 级
* 0 到 9 级的走法有 x，0 到 8 级的走法有 y 种，那么 0 到 10 级的走法一共有 x+y
* F(10) = F(9) + F(8)，F(8) = F(8) + F(7)
*  F(9) 和 F(8) 是 F(10) 的最优子结构
* 边界是 F(1) 和 F(2)
* 状态转移方程是 F(n) = F(n-1) + F(n-2)

```js
function getClimbingWays(n) {
    if (n < 1) return 0
    if (n === 1) return 1
    if (n === 2) return 2
    let a = 1, b = 2, temp = 0
    for (let i = 3; i <= n; i++) {
        temp = a + b
        a = b
        b = temp
    }
    return temp
}
```

## 最大子序列和

```js
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

* 分析：答案肯定是在以下组合中：
* 第一个子组合是以第一个数字结尾的连续序列，也就是[-2]，最大值-2
* 第二个子组合是以第二个数字结尾的连续序列，也就是[-2,1], [1]，最大值1
* 第三个子组合是以第三个数字结尾的连续序列，也就是[-2,1,-3], [1,-3], [-3]，最大值-2
* 第四个子组合是以第四个数字结尾的连续序列，也就是[-2,1,-3,4],[1.-3,4],[-3,4],[4]，最大值4
* 第n个子组合......

****

* 最优子结构：组合n只是在组合n-1的基础上每一个数组后面添加1个数字num，然后增加一个只有第n个数字的数组[num]，只需要比较前一个组合的最大值+num和num
* 边界：dp[0] = nums[0] = -2
* 状态转移方程：dp[i] = max(dp[i-1]+nums[i], nums[i])

```js
// 组合3只是在组合2的基础上每一个数组后面添加第3个数字，也就是3，然后增加一个只有第三个数字的数组[3]
// 只需要比较前一个组合的最大值+num和num
// 计算出九个组合的最大值，再取最大的即可

var maxSubArray = function(nums) {
    let dp = []
    let result = nums[0]
    dp[0] = nums[0]
    for(let i = 1; i < nums.length; i++){
        dp[i] = Math.max(dp[i-1]+nums[i],nums[i])
        if(dp[i] > result) result = dp[i]
    }
    return result
};
```

## 最长回文子串

* [leetcode5](https://leetcode-cn.com/problems/longest-palindromic-substring)

```js
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

示例 2：
输入: "cbbd"
输出: "bb"
```

* 分析：i 到 j 是回文子串那么 i+1 到 j-1 也是回文子串
* i 到 j 的最优子结构就是 i+1 到 j-1
* 边界就是单个字符或者 aa 这种
* 状态转移方程是：`dp[i][j] = dp[i+1][j-1] && s[i] == s[j]`

```js
var longestPalindrome = function(s) {
    if (!s) return ""
    let res = [], dp = []

    // 从后向前遍历，因为 dp[i] 依赖于 dp [i+1]
    for (let i = s.length - 1; i >= 0; i--) {
        dp[i] = []
        for (let j = i; j < s.length; j++) {
            // 边界
            if (i === j || (j - i === 1 && s[i] === s[j])) {
                dp[i][j] = true
            }
            // 状态转移
            else if (s[i] === s[j] && dp[i + 1][j - 1]) {
                dp[i][j] = true
            }
            if (dp[i][j] && j - i + 1 > res.length) {
                res = s.slice(i, j + 1);
            }
        }
    }
    return res
};
```

## 不同路径

* [leetcode62](https://leetcode-cn.com/problems/unique-paths/)

```js
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

示例 1:
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

示例 2:
输入: m = 7, n = 3
输出: 28
```

* 分析：到达终点总是向右或向下，故到达终点的走法=到达其上面点的走法 + 到达其左面点的走法
* 状态转移：`map[m][n] = map[m-1][n] + map[m][n-1]`
* 边界：`map[0][j] = 1,map[i][0] = 1`

```js
	// 初始化二维数组
    let map = Array.from(new Array(m),()=>(new Array(n).fill(0)))
    for (let j = 0; j < n; j++) {
        map[0][j] = 1
    }
    for (let i = 0; i < m; i++) {
        map[i][0] = 1
    }
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            map[i][j] = map[i-1][j] + map[i][j-1]
        }
    }
    return map[m-1][n-1]
```

#### Array.from

**将一个类数组对象或者可遍历对象转换成一个真正的数组。**

* 该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。

* 该类数组对象的属性名必须为数值型或字符串型的数字

* 该类数组对象的属性名可以加引号，也可以不加引号
* `Array.from`可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。

## 最小路径和

* [leetcode64](https://leetcode-cn.com/problems/minimum-path-sum/)

```js
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例 1：
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。

示例 2：
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

* 思路：到`grid[i][j]`的最小值，肯定等于到`grid[i-1][j]`的最小值和到`grid[i][j-1]`的最小值中较小的加上当前`grid[i][j]`的值
* 最优子结构：`dp[i-1][j], dp[i][j-1]`中小的那个
* 边界：`dp[0][0] = grid[0][0]`
* 状态转移方程：`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] `；

```js
var minPathSum = function(grid) {
    let m = grid.length
    let n = grid[0].length
    let dp = Array.from(new Array(m),()=>(new Array(n).fill(0)))
    dp[0][0] = grid[0][0]
    for (let i = 1; i < m; i++) {
        dp[i][0] = dp[i-1][0] + grid[i][0];
    }
    for (let j = 1; j < n; j++) {
        dp[0][j] = dp[0][j-1] + grid[0][j];
    }
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = Math.min(dp[i][j-1], dp[i-1][j]) + grid[i][j];
        }
    }
    return dp[m-1][n-1]
};
```

## 正则表达式匹配

* [leetcode10](https://leetcode-cn.com/problems/regular-expression-matching/)

* [题解](https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/)

## 分割等和子集

* [leetcode416](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

> 这个问题可以转化为求数组的一个子集，使得这个子集中的元素的和尽可能接近sum/2，其中sum为数组中所有元素的和。这样转换之后这个问题就很类似0-1背包问题了：在n件物品中找到m件物品，他们的可以装入背包中，且总价值最大不过这里不考虑价值，就考虑使得这些元素的和尽量接近sum/2。

* [背包问题分析](https://juejin.cn/post/6844903607855251463)

```js
输入: n物品重W[1:n], 价值V[1:n], 背包容量C
输出: 装包使得价值最大 (物品重量为整数).

dp[i,k] = 由[1:i]组合出重量<=k的最大价值

如果第i件物品没有包括在其中，则dp[i,k] = dp[i-1,k]
如果第i件物品包括在其中，则dp[i,k] = dp[i-1,k-W[i]] + V[i]

转移方程：dp[i,k] = max{ dp[i-1,k], dp[i-1,k-W[i]] + V[i] }
```

```js
var canPartition = function(nums) {
    let len = nums.length
    let sum = 0
    for (let i = 0; i < len; i++) {
        sum += nums[i]
    }
    let midSum = sum >> 1
    let dp = Array.from(new Array(len + 1),()=>(new Array(midSum + 1).fill(0)))
    for (let i = 1; i <= len; i++) {
        for (let j = 1; j <= midSum; j++) {
            if (j >= nums[i - 1]) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i-1]] + nums[i - 1])
            }
            else {
                dp[i][j] = dp[i - 1][j]
            }
        }
    }
    return dp[len][midSum] === sum / 2
};
```

## 三角形的最小路径和

* [leetcode120](https://leetcode-cn.com/problems/triangle/)

```js
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

* `dp[i][j]`表示从三角形顶部走到位置 (i, j) 的最小路径和，因此要想走到位置 (i, j)，上一步就只能在位置 (i - 1, j - 1)或者位置 (i - 1, j)

* 状态转移方程：`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]`

* 边界条件：`dp[0][0] = triangle[0][0] `
* 三角形的两腰上的 dp 值是确定的
  * `dp[i][0] = dp[i-1][0] + triangle[i][0] `
  * `dp[i][i] = dp[i-1][i-1] + triangle[i][i] `

```js
var minimumTotal = function(triangle) {
    const len = triangle.length
    let dp = Array.from(new Array(len),()=>(new Array(len).fill(0)))
    dp[0][0] = triangle[0][0]
    for (let i = 1; i < len; i++) {
        dp[i][0] = dp[i-1][0] + triangle[i][0]
        for (let j = 1; j < i; j++) {
            dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]
        }
        dp[i][i] = dp[i-1][i-1] + triangle[i][i]
    }
    return Math.min(...dp[len-1])
};
```

## 买卖股票的最佳时机

* [leetcode121](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```js
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票。

示例 1:
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
     
示例 2:
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

> 设 `dp[i]`为`i`支股票的最大利润，若已知前`i-1`支股票的最大利润为 `dp[i-1]`，怎么建立动态转移方程？
>
> 如果记录了前`i-1`支股票的最小值 min，那么最大利润一定是第`i`支股票的价格减去min所得的值与`dp[i-1]`之间的最大值，所以只需计算一下 `price[i] - min` 与` dp[i]` 的最大值

* 动态规划的三要素：最优子结构，边界，状态转移方程
* `dp[i]` 的 最优子结构就是 `dp[i-1]`
* 边界：`dp[0] = 0`
* 状态转移方程：`dp[i] = Math.max(dp[i-1], prices[i] - min);`

```js
var maxProfit = function(prices) {
    let dp = new Array(prices.length).fill(0)
    dp[0] = 0
    let min = prices[0]
    for (let i = 1; i < prices.length; i++) {
        dp[i] = Math.max(dp[i-1], prices[i] - min)
        if (min > prices[i]) {
            min = prices[i]
        }
    }
    return dp[dp.length-1]
};
```

代码优化之后（看了[官方题解](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/)才领悟到不用 dp 也可直接写出如下）

```js
let maxProfit = function(prices) {
    let max = 0, min = prices[0]
    for(let i = 1; i < prices.length; i++) {
        min = Math.min(prices[i], min)
        max = Math.max(max, prices[i] - min)
    }
    return max
}
```

## 买卖股票的最佳时机（含冷冻期）

```js
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例:
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

