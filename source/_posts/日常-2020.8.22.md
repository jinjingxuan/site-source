---
title: 日常-8.22
date: 2020-08-22 10:27:54
categories: 日常
---

* ES 2017
* yarn：另一种包管理工具
* 清除命令行：cls
* 内存
* 浏览器：disabled cache
* 函数封装：修改url参数

<!--more-->

## ES 2017

* Object.values
* Object.entries
* Object.getOwnPropertyDescriptors
* String.prototype.padStart
* Sting.prototype.padEnd
* 函数参数中添加尾逗号

``` js
const obj = {
    foo: 'value1',
    bar: 'value2'
}

console.log(Object.keys(obj))   // 键
console.log(Object.values(obj)) // 值

console.log(Object.entries(obj))
// [["foo", "value1"], ["bar", "value2"]]

// 可以用这种方法来遍历对象
for(const [key, value] of Object.entries(obj)) {
    console.log(key, value)
}

// 对象转换为Map
new Map(Object.entries(obj))

Object.getOwnPropertyDescriptors(obj)
// 获取对象的完整描述信息
// {foo: {…}, bar: {…}}

// foo:
// value: "value1"
// writable: true
// enumerable: true
// configurable: true

// bar:
// value: "value2"
// writable: true
// enumerable: true
// configurable: true

//padEnd和padStart可以使输出更工整
const books = {
    html: 5,
    css: 16,
    javascript: 128
}
for(const [name, count] of Object.entries(books)) {
    console.log(`${name.padEnd(16, '-')}|${count.toString().padStart(3, '0')}`)
}

// html------------|005
// css-------------|016
// javascript------|128

// 尾逗号，方便代码管理
const arr = [
    100,
    200,
    300,
]
```

## yarn：另一种包管理工具

FaceBook 开源的一个新的包管理器， 和npm的作用是一样的，但是解决了一些npm的痛点。

安装：`npm install -g yarn`

### yarn的常用命令

| npm                           | yarn                           |
| ----------------------------- | ------------------------------ |
| npm init                      | yarn init                      |
| npm install                   | yarn install                   |
| npm install --no-package-lock | yarn install --no-package-lock |
| npm install xxx --save        | yarn add xxx                   |
| npm install xxx --save-dev    | yarn add xxx --dev             |
| npm uninstall xxx --save      | yarn remove xxx                |
| yarn add xx@version           | npm install xx@vision          |
| yarn upgrade xx               | npm update xx                  |
| yarn upgrade xx@version       | npm update xx@vision           |
| yarn why xx                   | -                              |
| yarn config list              | npm config list                |

## 内存

在程序运行的时候，整块内存可以划分为：

- 常量池（存放基本类型的值）
- 栈（存放变量）
- 堆（存放对象）
- 运行时环境（函数运行时） 

## 浏览器：disabled cache

浏览器调试工具的disable cache功能，开启这个功能，浏览器关于当前网站的js、css、图片等缓存都会失效，所有请求都会重新发送给服务器。`ctrl`+`F5`也可以达到同样的效果。  

> 当勾选Disable cache重新加载页面后，再取消勾选Disable cache重新加载页面，会发现浏览器立即就使用缓存了，由此可以证明我上面的结论：**缓存一直都在，只不过就看浏览器想不想用了**。 

## 函数封装：修改url参数

```js
/**
 * 函数功能：修改 url 中的某一个参数
 * 如果 url 中不存在该参数 arg，则添加参数 arg = newValue
 * 如果 newValue 为 undefine || '' 则删除该 arg
 * 存在 则将 url 中的 arg 的值改为 newValue
 */

/**
 *
 * 当newValue为空时：删除该 arg 参数，例如
 *   1. 匹配到?arg=value& 删掉 arg=value&
 *   2. 匹配到?arg=value  删掉 ?arg=value
 *   3. 匹配到&arg=value& 删掉 &arg=value
 *   4. 匹配到&arg=value  删掉 &arg=value
 * 当newValue不为空时：
 *   1. url 里存在   arg => 替换
 *   2. url 里不存在 arg => 增加 :  (1)url 里原来有参数时，添加 $arg=newValue
 *                                 (2)url 里原来无参数时，添加 arg=newValue
 */
                                                    
function changeURLArg (url, arg, newValue) {
    const reg = `${arg}=([^&]*)`
    const reg1 = eval(`/\\?${reg}&/g`)    // 匹配到?arg=value&
    const reg2 = eval(`/(\\?|&)${reg}/g`) // 匹配到?arg=value 或者 &arg=value
    const reg3 = eval(`/&${reg}&/g`)      // 匹配到&arg=value 
    if(!newValue) {
        url = url.replace(reg1, '?').replace(reg2, ``).replace(reg3, `&`)
    } else {
        if(url.match(eval(`/${reg}/g`))) {
            url = url.replace(eval(`/${reg}/g`), `${arg}=${newValue}`)
        } else {
            url += url.indexOf('?') !== - 1 ? `&${arg}=${newValue}` : `?${arg}=${newValue}`
        }
    }
    return url
}

let url = "http://focus.cn?name=jin&age=18"
console.log(changeURLArg(url, 'name', 'a'))
```

* 为什么要用eval？：\`/\\?${reg}&/g\` 这种是字符串形式，用eval转换为正则表达式形式
* ？需要转义，如果用eval的话就需要用 \\\
* 正常情况下只用一个 \    `'123?'.match(/\?/g)`

 

 