---
title: 计算机基础
date: 2020-11-23 11:27:54
categories: 计算机基础
---

* osi七层模型与tcp/ip五层模型
* TCP与UDP的区别
* TCP三次握手，四次挥手
* 什么是HTTP协议
* 长连接与多路复用
* HTTPS
* 进程与线程
* 基于对象与面向对象

## osi七层模型与tcp/ip五层模型

**OSI定义了网络互连的七层框架**

* 应用层：针对你特定应用的协议
* 表示层：设备固定的数据格式和网络标准数据格式之间的转化
* 会话层：通信管理，负责建立和单开通信连接，管理传输层 以下分层
* 传输层：管理两个节点之间的数据传递。负责可靠传输
* 网络层：地址管理和路由选择
* 数据链路层：互联设备之间传送和识别数据帧
* 物理层：界定连接器和网线之间的规格

**TCP/IP四（五）层模型**

每一层都呼叫它的下一层提供的网络来完成自己的需求。（如果是四层模型数据链路层和物理层在一层）

* 物理层：负责光电信号传递方式。集线器工作在物理层。以太网协议。
* 数据链路层：负责设备之间的数据帧的传输和识别。交换机工作在数据链路层。例如网卡设备的驱动，帧同步，冲突检测，数据差错校验等工作。
* 网络层：负责地址管理和路由选择。路由器工作在网络层。
* 传输层：负责两台主机之间的数据传输。
* 应用层：负责应用程序之间的沟通。网络编程主要针对的就是应用层。

## TCP与UDP的区别

* tcp 和 udp 都是属于传输层，传输层提供应用程序间的通信，其功能包括格式化信息流，提供可靠传输。

* TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

* TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。

* Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

* UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

**为什么UDP有时比TCP更有优势?**

* UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。

* 网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。

* TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。

* 采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响

## TCP三次握手，四次挥手

```js
三次握手：通俗的讲
                客户端：HI听见了吗,
                服务器端：HI我听见了，
                客户端：我也听见你了。     接下来开始愉快地聊天
四次握手：通俗的讲
                客户端：我们分手把，
                服务端：好的，你等我把数据给你传输完
                服务端：我传输完了，
                客户端：好了，可以分手了。 接下来就真正的分手了
```

* [三次握手](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
* [四次挥手](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
* SYN (synchronous建立联机) 
* ACK (acknowledgement 确认) 
* FIN (finish结束) 
* Sequence number (顺序号码) 
* 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态

```js
为了保证A发送的最后一个ACK报文能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。
```

## 什么是 HTTP 协议

> 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。

| 版本     | 产生时间 | 内容                                                         | 发展现状           |
| -------- | -------- | ------------------------------------------------------------ | ------------------ |
| HTTP/0.9 | 1991年   | 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求 | 没有作为正式的标准 |
| HTTP/1.0 | 1996年   | 传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令 | 正式作为标准       |
| HTTP/1.1 | 1997年   | 持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码   | 2015年前使用最广泛 |
| HTTP/2   | 2015年   | 多路复用、服务器推送、头信息压缩、二进制协议等               | 逐渐覆盖市场       |

## 长连接与多路复用

* 长连接：在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
* 多路复用：在 HTTP 1.0 中，发起一个请求是这样的：


```js
浏览器请求 url -> 解析域名 -> 建立 HTTP 连接 -> 服务器处理文件 -> 返回数据 -> 浏览器解析、渲染文件 

这个流程最大的问题是，每次请求都需要建立一次 HTTP 连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，而且逻辑上是非必需的，因为不间断的请求数据，第一次建立连接是正常的，以后就占用这个通道，下载其他文件，这样效率多高啊！

为了解决这个问题， HTTP 1.1 中提供了 Keep-Alive，允许我们建立一次 HTTP 连接，来返回多次请求数据。

但是这里有两个问题：

HTTP 1.1 基于串行文件传输数据，因此这些请求必须是有序的，比如需要传输：hello world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序。所以实际上我们只是节省了建立连接的时间，而获取数据的时间并没有减少

最大并发数问题，假设我们在 Apache 中设置了最大并发数 300，而因为浏览器本身的限制，最大请求数为 6，那么服务器能承载的最高并发数是 50

而 HTTP/2 引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据。

HTTP/2 对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样Apache的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍。
```

## HTTPS

HTTP请求都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求被黑客拦截，并且里面含有银行卡密码等敏感数据的话，会非常危险。为了解决这个问题，Netscape 公司制定了HTTPS协议，HTTPS可以将数据加密传输，也就是传输的是密文，即便黑客在传输过程中拦截到数据也无法破译，这就保证了网络通信的安全。

* HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的，保证了通信的保密性。当然SSL协议并不能对UDP应用进行保护

* 虽然使用 HTTP 协议无法确定通信方，使用 SSL可以。SSL使用了一种被称为证书的手段，证书由值得信任的第三方机构颁发，使用HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。证书用以证明服务器和客户端是实际存在的。身份确认过程使用RSA非对称密钥加密方式（破解难度基于两个大素数乘积的因式分解难度），但是为了提高效率，身份确认完成后使用共商后的对称密钥。

* SSL协议位于TCP/IP协议与各种应用层协议（不止能用于HTTP）之间，为数据通讯提供安全支持。

  SSL协议可分为两层：

  （1）SSL记录协议：建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。

  （2）SSL握手协议：建立在记录协议之上，用于数据传输开始前的双方身份认证、协商加密算法、交换加密密钥等。

* 主要流程：

  * 客户端向服务器发起HTTPS请求，连接到服务器的443端口
  * 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
  * 服务器将自己的公钥发送给客户端。
  * 客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
  * 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
  * 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
  * 然后服务器将加密后的密文发送给客户端。
  * 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。
  
* **注意：** **HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。**

* 为什么数据传输是用对称加密的？

  - 非对称加密的加解密**效率非常低**，而HTTP的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。
  - 在 HTTPS 的场景中只有服务端保存了私钥，**客户端不做非对称密钥生成**，一对公钥和私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。

****

> https并非应用层的一种新协议，只是http通信接口部分用ssl/tls协议代替而已。
>
> SSL和TLS都是加密协议
> 通常http直接和tcp通信，当使用ssl时则演变成先和ssl通信，再由ssl和tcp通信。
> 所谓https，其实就是身披ssl协议这层外壳的http。（回忆一下osi7层,TCP/IP4层，我们学的是5层）
>
> SSL协议采用的是非对称加密算法，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密.
>
> RSA算法：两个大素数p,q，n=pq,f(n)=(p-1)(q-1),1<b<f(n),a=b^-1modf(n),公钥n,b,私钥p,q,a
>
> 证书，顾名思义，就是证明的文件。例如浏览器和 tlanyan.me 服务器通信，浏览器怎么知道对方就是 tlanyan.me 对应的服务器呢？在不可信的网络下通信，中立的第三方作用就显现出来了。权威的第三方中立机构（ Certificate Authority, CA）收到 tlanyan.me 持有者的证书请求并核验信息后，将持有者的名称、公钥与 CA 用私钥生成的数字签名等信息写成证书颁发给申请者。
>
> 当你访问使用 HTTPS（连接安全）的网站时，该网站的服务器会使用证书向浏览器（如 Chrome）证明该网站的身份。任何人都可以创建证书，随意声称对应的网站是任意网站。
>
> 为了确保您安全上网，Chrome 会要求网站使用来自受信任组织发放的证书。

## 进程与线程

- 进程是CPU资源分配的最小单位（能拥有资源和独立运行的最小单位）
- 线程是CPU调度的最小单位（线程是建立在进程基础上的一次程序运行单位，一个进程可以有多个线程）
- 同一进程中的多条线程讲共享该进程中的全部系统资源，但是同一进程中的多个线程有各自的调用栈，自己的线程本地存储。一个进程可以有很多线程，每条线程并行执行不同的任务
- 进程间通信方式：管道、信号量、消息队列、共享内存、套接字（socket）。
- 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。（锁机制：包括互斥锁、条件变量、读写锁，信号量机制(Semaphore)，信号机制(Signal)）

## 基于对象与面向对象

* 面向对象的三大特点（封装，继承，多态）缺一不可，例如 c++，java
* 基于对象的语言，使用一些封装好的对象，调用对象的方法，设置对象的属性，但是无法派生新的对象类型，只能使用现有对象的方法和属性。
* javascript虽然通过原型链等实现了继承，通过arguments实现函数重载等特点，但是都是属于模拟实现，本质上还是基于对象的语言，实际上可以实现面向对象编程。